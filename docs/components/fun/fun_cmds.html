<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>Comrade.components.fun.fun_cmds API documentation</title>
<meta name="description" content="Fun commands ‚Ä¶" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Comrade.components.fun.fun_cmds</code></h1>
</header>
<section id="section-intro">
<p>Fun commands</p>
<p>Fanfic by Kevin Zhao
Fortnite Dance and Text Manipulation by Kevin Hu
Shoujo Commands by Maggie Wang</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
Fun commands

Fanfic by Kevin Zhao
Fortnite Dance and Text Manipulation by Kevin Hu
Shoujo Commands by Maggie Wang
&#39;&#39;&#39;

import discord
from discord.ext import commands

import asyncio
import random
import io
import urllib.request
from bs4 import BeautifulSoup
from PIL import Image

from utils.emoji_converter import emojiToText, textToEmoji
from utils.echo import echo, mimic
from utils.utilities import webscrape_header

from utils.logger import logger

# Static dependencies
with open(&#34;static/space.txt&#34;, &#34;r&#34;, encoding=&#34;utf-8&#34;) as f:
    space = f.read()

with open(&#34;static/default_dance.txt&#34;, &#34;r&#34;, encoding=&#34;utf-8&#34;) as f:
    default_dance = f.readlines()

with open(&#39;static/sparkles.txt&#39;, &#39;r&#39;, encoding=&#34;utf-8&#34;) as sparklesFile:
    sparkles = [s.strip() for s in sparklesFile.readlines()]

with open(&#39;static/yukis_feelings.txt&#39;, &#39;r&#39;, encoding=&#34;utf-8&#34;) as kimochiFile:
    thoughts = kimochiFile.read().splitlines()
    # TL Note: kimochi means feeling, but in Japanese


def fortnite_dance():
    &#39;&#39;&#39;
    Iterator generator for producing Fortnite Default Dance
    This assumes that the source file separates each dance frame by
    one blank line, and has no blank lines within the dance frames themselves.
    Generalizable to basically any sort of text animation!
    &#39;&#39;&#39;
    position = 0
    accum = &#34;&#34;

    while position &lt; len(default_dance):
        if not default_dance[position].strip():
            yield accum
            accum = &#34;&#34;
        else:
            accum += default_dance[position]
        position += 1
    yield accum


def owoify(t):
    &#39;&#39;&#39;
    Replaces L, R, with w
    &#39;&#39;&#39;
    remove_characters = [&#34;R&#34;, &#34;L&#34;, &#34;r&#34;, &#34;l&#34;]
    for character in remove_characters:
        if character.islower():
            t = t.replace(character, &#34;w&#34;)
        else:
            t = t.replace(character, &#34;W&#34;)
    return t


def emojify(guild, t):
    &#39;&#39;&#39;
    Substitute spaces with emojis from a guild
    &#39;&#39;&#39;
    return &#34;&#34;.join([str(random.choice(guild.emojis))
                    if s == &#34; &#34; else s for s in t])


def mock(t):
    &#39;&#39;&#39;
    Randomly captializes and lowercases letters in string
    &#39;&#39;&#39;
    s = &#34;&#34;
    for character in t:
        if random.random() &lt; 0.5:
            s += character.lower()
        else:
            s += character.upper()
    return s


async def shoujosend(ctx: commands.Context, content,
                     file: discord.File = None,
                     embed: discord.Embed = None, tts=False):
    &#39;&#39;&#39;
    Send the message, except as a cute anime girl
    &#39;&#39;&#39;
    if ctx.guild:
        await ctx.send(content=content, file=file, embed=embed, tts=tts)
    else:
        await mimic(ctx.channel, content=content,
                    username=&#34;Yuki Chan&#34;,
                    avatar_url=&#34;https://cdn.discordapp.com/attachments/420664953435979806/749064831935447071/Annotation_2020-08-24_174359.jpg&#34;,
                    file=file, embed=embed, tts=tts)


class Fun(commands.Cog):
    &#39;&#39;&#39;
    Fun stuff.
    (Text manipulation, stopping time)
    [Try typing &#34;STAR PLATINUM&#34;]
    &#39;&#39;&#39;

    def __init__(self, bot):
        self.bot: commands.Bot = bot

        self.activeGuess = None
        self.guessState = False
        self.streak = {}  # NOTE: Changed to dictionary

    @commands.command()
    async def space(self, ctx: commands.Context):
        &#39;&#39;&#39;
        Posts text with stars and space. Best used on dark theme.
        &#39;&#39;&#39;
        await ctx.send(space)

    @commands.command()
    async def textToEmoji(self, ctx: commands.Context, *, text):
        &#39;&#39;&#39;
        Converts text to emoji
        &#39;&#39;&#39;
        await ctx.send(textToEmoji(text))

    @commands.command()
    async def emojiToText(self, ctx: commands.Context, *, text):
        &#39;&#39;&#39;
        Converts emoji to text
        &#39;&#39;&#39;
        await ctx.send(emojiToText(text))

    @commands.command()
    async def fanfic(self, ctx: commands.Context, *, site):
        &#39;&#39;&#39;
        Scrapes text from a webpage with text, and pastes it here
        by Kevinozoid.
        &#39;&#39;&#39;
        await ctx.trigger_typing()

        request = urllib.request.Request(site, None, webscrape_header())
        req = urllib.request.urlopen(request)
        html = req.read()
        soup = BeautifulSoup(html, features=&#34;html.parser&#34;)

        for script in soup([&#34;script&#34;, &#34;style&#34;]):
            script.extract()

        holyText = soup.get_text()

        holyText = &#34;\n&#34;.join([s for s in holyText.splitlines() if s.strip()])

        if len(holyText) &gt; 10000:
            holyText = holyText[:10000]
            await ctx.send(
                &#34;(Text was trimmed to first 10000 characters for being too long.)&#34;)

        paginator = commands.Paginator(prefix=&#34;&#34;, suffix=&#34;&#34;)

        lines = holyText.splitlines()

        lines = [lines[i] for i in range(len(lines))]

        for line in lines:
            paginator.add_line(line)

        for page in paginator.pages:
            await ctx.send(page)
            await asyncio.sleep(1)
        await ctx.send(&#34;**&lt;END OF TEXT&gt;**&#34;)

    @commands.command()
    @commands.guild_only()
    async def timestop(self, ctx: commands.Context, time: int = 5):
        &#39;&#39;&#39;
        Stops time.
        &#39;&#39;&#39;
        # Make a GIF embed of Jotaro saying &#34;STAR PLATINUM ZA WARUDO&#34;
        embed = discord.Embed(
            title=&#34;ZA WARUDO&#34;, colour=discord.Colour.purple())
        embed.set_image(url=(
            &#34;https://media1.tenor.com/images/4b953bf5b5ba531099a823944a5626c2/tenor.gif&#34;))

        await ctx.send(embed=embed, delete_after=1.95)

        # Revoke ability for @everyone to send messages
        current_permissions = ctx.channel.overwrites_for(
            ctx.guild.default_role)
        modified_permissions = discord.PermissionOverwrite.from_pair(
            *current_permissions.pair())
        modified_permissions.send_messages = False
        await ctx.channel.set_permissions(ctx.guild.default_role, overwrite=modified_permissions)

        # Pause while Jotaro gif is playing
        await asyncio.sleep(1.95)

        announcement_msg = await ctx.send(&#34;*Time is frozen*&#34;)

        # Count the seconds in stopped time, but only if the stop time is less
        # than 20s
        if int(time) &lt;= 20:
            for i in range(int(time)):
                await asyncio.sleep(1)
                t = i + 1
                if t == 1:
                    await announcement_msg.edit(content=&#34;1 second has passed&#34;, suppress=False)
                else:
                    await announcement_msg.edit(content=f&#34;{t} seconds have passed&#34;, suppress=False)
        else:
            await asyncio.sleep(int(time) - 2 if int(time) &gt;= 2 else 0)

        # Restore original permissions
        await ctx.channel.set_permissions(ctx.guild.default_role, overwrite=current_permissions)

        await announcement_msg.edit(content=f&#34;*Time has begun to move again.*\n(Time stopped by {ctx.author.mention})&#34;, suppress=False)

        logger.info(ctx.guild,
                    f&#34;Timestop in {ctx.channel.name} lasting {time} seconds&#34;)

    @commands.Cog.listener()
    async def on_message(self, message: discord.Message):
        &#39;&#39;&#39;
        Emoji call listener
        &#39;&#39;&#39;
        if not message.author.bot:
            if message.content.lower()[0:3] == &#34;tte&#34;:
                await self.textToEmoji(await self.bot.get_context(message), text=message.content.lower().lstrip(&#34;tte &#34;))
            elif message.content.lower()[0:3] == &#34;ett&#34;:
                await self.emojiToText(await self.bot.get_context(message), text=message.content.lower().lstrip(&#34;ett &#34;))

            if message.guild and message.content == &#34;STAR PLATINUM&#34;:
                await self.timestop(await self.bot.get_context(message), 5)

    @commands.command()
    async def defaultdance(self, ctx: commands.Context):
        &#39;&#39;&#39;
        Posts Fortnite default dance animation
        &#39;&#39;&#39;
        frames = [frame for frame in fortnite_dance()]

        msg = await ctx.send(f&#34;```{frames[0]}```&#34;)

        for i in range(1, len(frames)):
            await asyncio.sleep(1)
            await msg.edit(content=f&#34;```{frames[i]}```&#34;)

        await asyncio.sleep(10)
        await msg.delete()

    @commands.command(name=&#34;owoify&#34;)
    async def cmdowoify(self, ctx: commands.Context, *, text: str = &#34;&#34;):
        &#39;&#39;&#39;
        changes all R&#39;s and L&#39;s to W&#39;s
        &#39;&#39;&#39;
        t = text.strip()

        if len(t) == 0:
            # owoify previous message
            msg = (await ctx.channel.history(limit=2).flatten())[1]
            auth = msg.author
            t = msg.content
        else:
            auth = ctx.author

        if ctx.guild:
            await echo(ctx, member=auth, content=owoify(t))
        else:
            await ctx.send(owoify(t))

    @commands.command(name=&#34;emojify&#34;)
    @commands.guild_only()
    async def cmdemojify(self, ctx: commands.Context, *, text: str = &#34;&#34;):
        &#39;&#39;&#39;
        adds random emojis in spaces
        &#39;&#39;&#39;
        t = text.strip()

        if len(t) == 0:
            msg = (await ctx.channel.history(limit=2).flatten())[1]
            auth = msg.author
            t = msg.content
        else:
            auth = ctx.author

        await echo(ctx, member=auth, content=emojify(ctx.guild, t))

    @commands.command(name=&#34;mock&#34;)
    async def cmdmock(self, ctx: commands.Context, *, text: str = &#34;&#34;):
        &#39;&#39;&#39;
        randomly capitalizes and lowercases a message
        &#39;&#39;&#39;

        t = text.strip()

        if len(t) == 0:
            msg = (await ctx.channel.history(limit=2).flatten())[1]
            auth = msg.author
            t = msg.content
        else:
            auth = ctx.author

        if ctx.guild:
            await echo(ctx, member=auth, content=mock(t))
        else:
            await ctx.send(mock(t))

    @commands.command()
    @commands.guild_only()
    async def fuckup(self, ctx: commands.Context, *, text: str = &#34;&#34;):
        &#39;&#39;&#39;
        Apply every single effect possible to some text
        &#39;&#39;&#39;
        t = text.strip()
        if len(t) == 0:
            msg = (await ctx.channel.history(limit=2).flatten())[1]
            auth = msg.author
            t = msg.content
        else:
            auth = ctx.author

        await echo(ctx, member=auth,
                   content=owoify(emojify(ctx.guild, mock(t))))

    @commands.command()
    async def futa(self, ctx: commands.Context, m: discord.Message = None):
        &#39;&#39;&#39;
        Developed by Futanari Yaoi.
        Search on Google to learn more about his work
        &#39;&#39;&#39;
        if not m:
            m = (await ctx.channel.history(limit=2).flatten())[1]

        # spell futanari yaoi
        await m.add_reaction(u&#34;\U0001F1EB&#34;)
        await m.add_reaction(u&#34;\U0001F1FA&#34;)
        await m.add_reaction(u&#34;\U0001F1F9&#34;)
        await m.add_reaction(u&#34;\U0001F1E6&#34;)
        await m.add_reaction(u&#34;\U0001F1F3&#34;)
        await m.add_reaction(&#34;üÖ∞Ô∏è&#34;)
        await m.add_reaction(u&#34;\U0001F1F7&#34;)
        await m.add_reaction(u&#34;\U0001F1EE&#34;)

        await m.add_reaction(&#34;‚ñ™Ô∏è&#34;)

        await m.add_reaction(u&#34;\U0001F1FE&#34;)
        await m.add_reaction(&#34;4Ô∏è‚É£&#34;)
        await m.add_reaction(&#34;0Ô∏è‚É£&#34;)
        await m.add_reaction(&#34;‚ÑπÔ∏è&#34;)

        await m.add_reaction(&#34;‚óºÔ∏è&#34;)
        await m.add_reaction(&#34;‚ôÄÔ∏è&#34;)
        await m.add_reaction(&#34;‚ôÇÔ∏è&#34;)
        await m.add_reaction(&#34;üçÜ&#34;)
        await m.add_reaction(&#34;üí¶&#34;)

    @commands.command()
    async def ascii(self, ctx: commands.Context, character: str, *, text):
        &#39;&#39;&#39;
        Sends a big form of a character in word art form. Can use emojis too.
        &#39;&#39;&#39;
        if ctx.guild and (
                e := discord.utils.get(ctx.guild.emojis, name=character)):
            character = str(e)

        letters = {&#34;a&#34;: &#34;###\n#b#\n###\n#b#\n#b#&#34;,
                   &#34;b&#34;: &#34;##b\n#b#\n###\n#b#\n##b&#34;,
                   &#34;c&#34;: &#34;###\n#bb\n#bb\n#bb\n###&#34;,
                   &#34;d&#34;: &#34;##b\n#b#\n#b#\n#b#\n##b&#34;,
                   &#34;e&#34;: &#34;###\n#bb\n###\n#bb\n###&#34;,
                   &#34;f&#34;: &#34;###\n#bb\n###\n#bb\n#bb&#34;,
                   &#34;g&#34;: &#34;b##\n#bb\n#b#\n#b#\nb##&#34;,
                   &#34;h&#34;: &#34;#b#\n#b#\n###\n#b#\n#b#&#34;,
                   &#34;i&#34;: &#34;###\nb#b\nb#b\nb#b\n###&#34;,
                   &#34;j&#34;: &#34;###\nb#b\nb#b\nb#b\n#bb&#34;,
                   &#34;k&#34;: &#34;#bb\n#b#\n#b#\n#b#\n#b#&#34;,
                   &#34;l&#34;: &#34;#bb\n#bb\n#bb\n#bb\n###&#34;,
                   &#34;m&#34;: &#34;#b#\n###\n###\n#b#\n#b#&#34;,
                   &#34;n&#34;: &#34;bbb\nbbb\n##b\n#b#\n#b#&#34;,
                   &#34;o&#34;: &#34;###\n#b#\n#b#\n#b#\n###&#34;,
                   &#34;p&#34;: &#34;###\n#b#\n###\n#bb\n#bb&#34;,
                   &#34;q&#34;: &#34;b#b\n#b#\n#b#\nb##\nbb#&#34;,
                   &#34;r&#34;: &#34;##b\n#b#\n##b\n#b#\n#b#&#34;,
                   &#34;s&#34;: &#34;###\n#bb\n###\nbb#\n###&#34;,
                   &#34;t&#34;: &#34;###\nb#b\nb#b\nb#b\nb#b&#34;,
                   &#34;u&#34;: &#34;#b#\n#b#\n#b#\n#b#\n###&#34;,
                   &#34;v&#34;: &#34;#b#\n#b#\n#b#\n#b#\nb#b&#34;,
                   &#34;w&#34;: &#34;#b#\n#b#\n###\n###\n#b#&#34;,
                   &#34;x&#34;: &#34;#b#\n#b#\nb#b\n#b#\n#b#&#34;,
                   &#34;y&#34;: &#34;#b#\n#b#\nb#b\nb#b\nb#b&#34;,
                   &#34;z&#34;: &#34;###\nbb#\nb#b\n#bb\n###&#34;,
                   &#34; &#34;: &#34;bbb\nbbb\nbbb\nbbb\nbbb&#34;}
        try:
            out = &#34;&#34;

            # TO FIX
            def divide_chunks(lst, n):
                for i in range(0, len(lst), n):
                    yield lst[i:i + n]

            for c in text.lower():
                if c not in letters:
                    raise Exception
                ch = letters[c].replace(
                    &#34;b&#34;, &#34;:black_small_square:&#34;).replace(&#34;#&#34;, character)
                out += ch + &#34;\n\n&#34;

            if len(out) &gt; 2000:
                pg = commands.Paginator(prefix=&#34;&#34;, suffix=&#34;&#34;)

                count_so_far = 0

                for chunk in divide_chunks(out.splitlines(), 6):

                    # start new page if next chunk is too big
                    chunk_length = sum([len(ln) for ln in chunk])

                    if count_so_far + chunk_length &gt; 2000:
                        pg.close_page()
                        count_so_far = 0

                    for line in chunk:
                        pg.add_line(line)

                    count_so_far += chunk_length

                for page in pg.pages:
                    await ctx.send(page)
            else:
                await ctx.send(out)
        except KeyError:
            await ctx.send(&#34;Text must be alphabetical only.&#34;)

    @commands.command()
    async def secret(self, ctx: commands.Context):
        &#39;&#39;&#39;
        Sends all your deepest, darkest secrets into a black hole
        &#39;&#39;&#39;
        try:
            await ctx.message.delete()
        except Exception:
            pass

        await shoujosend(ctx,
                         content=&#34;Don&#39;t worry, your secret is safe with me~ (^_&lt;)„Äú‚òÜ&#34;)

    @commands.command()
    async def sparklify(self, ctx: commands.Context, *, message=None):
        &#39;&#39;&#39;
        makes your message extra kawaii desu~
        functions differently depending on whether you send text or an image
        &#39;&#39;&#39;
        feelings = random.choice(thoughts)
        if &#39;{}&#39; in feelings:
            friend = ctx.message.author.display_name

            shoujo_role_exists = &#39;Shoujotard&#39; in [
                r.name for r in ctx.guild.roles]
            author_has_shoujo_role = shoujo_role_exists and &#39;Shoujotard&#39; in [
                r.name for r in ctx.author.roles]

            # in the case that the Shoujotard role doesn&#39;t exist, call everyone chan
            # Else, only call those who have the Shoujotard role chan
            if (author_has_shoujo_role or not shoujo_role_exists):
                friend += &#39;-chan&#39;
            feelings = feelings.replace(&#39;{}&#39;, friend)

        if message:
            sparkle = random.choice(sparkles)

            sparklyMessage = f&#34;`{sparkle} {message} {sparkle[-1::-1]}`&#34;

            try:
                await ctx.message.delete()
            except BaseException:
                pass
            await shoujosend(ctx, sparklyMessage)

        else:
            f = io.BytesIO()
            await ctx.message.attachments[0].save(f)
            f.seek(0)
            ogImage = Image.open(f)
            size = max(ogImage.size)

            kiraKira = Image.open(&#34;static/sparkle.png&#34;).resize((size, size))
            ogImage.paste(kiraKira, (0, 0), kiraKira)

            f.seek(0)
            ogImage.save(f, &#34;PNG&#34;)
            f.seek(0)

            await shoujosend(ctx, content=feelings,
                             file=discord.File(f, &#39;sparklified.png&#39;))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="Comrade.components.fun.fun_cmds.emojify"><code class="name flex">
<span>def <span class="ident">emojify</span></span>(<span>guild, t)</span>
</code></dt>
<dd>
<div class="desc"><p>Substitute spaces with emojis from a guild</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def emojify(guild, t):
    &#39;&#39;&#39;
    Substitute spaces with emojis from a guild
    &#39;&#39;&#39;
    return &#34;&#34;.join([str(random.choice(guild.emojis))
                    if s == &#34; &#34; else s for s in t])</code></pre>
</details>
</dd>
<dt id="Comrade.components.fun.fun_cmds.fortnite_dance"><code class="name flex">
<span>def <span class="ident">fortnite_dance</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Iterator generator for producing Fortnite Default Dance
This assumes that the source file separates each dance frame by
one blank line, and has no blank lines within the dance frames themselves.
Generalizable to basically any sort of text animation!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fortnite_dance():
    &#39;&#39;&#39;
    Iterator generator for producing Fortnite Default Dance
    This assumes that the source file separates each dance frame by
    one blank line, and has no blank lines within the dance frames themselves.
    Generalizable to basically any sort of text animation!
    &#39;&#39;&#39;
    position = 0
    accum = &#34;&#34;

    while position &lt; len(default_dance):
        if not default_dance[position].strip():
            yield accum
            accum = &#34;&#34;
        else:
            accum += default_dance[position]
        position += 1
    yield accum</code></pre>
</details>
</dd>
<dt id="Comrade.components.fun.fun_cmds.mock"><code class="name flex">
<span>def <span class="ident">mock</span></span>(<span>t)</span>
</code></dt>
<dd>
<div class="desc"><p>Randomly captializes and lowercases letters in string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mock(t):
    &#39;&#39;&#39;
    Randomly captializes and lowercases letters in string
    &#39;&#39;&#39;
    s = &#34;&#34;
    for character in t:
        if random.random() &lt; 0.5:
            s += character.lower()
        else:
            s += character.upper()
    return s</code></pre>
</details>
</dd>
<dt id="Comrade.components.fun.fun_cmds.owoify"><code class="name flex">
<span>def <span class="ident">owoify</span></span>(<span>t)</span>
</code></dt>
<dd>
<div class="desc"><p>Replaces L, R, with w</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def owoify(t):
    &#39;&#39;&#39;
    Replaces L, R, with w
    &#39;&#39;&#39;
    remove_characters = [&#34;R&#34;, &#34;L&#34;, &#34;r&#34;, &#34;l&#34;]
    for character in remove_characters:
        if character.islower():
            t = t.replace(character, &#34;w&#34;)
        else:
            t = t.replace(character, &#34;W&#34;)
    return t</code></pre>
</details>
</dd>
<dt id="Comrade.components.fun.fun_cmds.shoujosend"><code class="name flex">
<span>async def <span class="ident">shoujosend</span></span>(<span>ctx:¬†discord.ext.commands.context.Context, content, file:¬†discord.file.File¬†=¬†None, embed:¬†discord.embeds.Embed¬†=¬†None, tts=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Send the message, except as a cute anime girl</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def shoujosend(ctx: commands.Context, content,
                     file: discord.File = None,
                     embed: discord.Embed = None, tts=False):
    &#39;&#39;&#39;
    Send the message, except as a cute anime girl
    &#39;&#39;&#39;
    if ctx.guild:
        await ctx.send(content=content, file=file, embed=embed, tts=tts)
    else:
        await mimic(ctx.channel, content=content,
                    username=&#34;Yuki Chan&#34;,
                    avatar_url=&#34;https://cdn.discordapp.com/attachments/420664953435979806/749064831935447071/Annotation_2020-08-24_174359.jpg&#34;,
                    file=file, embed=embed, tts=tts)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Comrade.components.fun.fun_cmds.Fun"><code class="flex name class">
<span>class <span class="ident">Fun</span></span>
<span>(</span><span>bot)</span>
</code></dt>
<dd>
<div class="desc"><p>Fun stuff.
(Text manipulation, stopping time)
[Try typing "STAR PLATINUM"]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Fun(commands.Cog):
    &#39;&#39;&#39;
    Fun stuff.
    (Text manipulation, stopping time)
    [Try typing &#34;STAR PLATINUM&#34;]
    &#39;&#39;&#39;

    def __init__(self, bot):
        self.bot: commands.Bot = bot

        self.activeGuess = None
        self.guessState = False
        self.streak = {}  # NOTE: Changed to dictionary

    @commands.command()
    async def space(self, ctx: commands.Context):
        &#39;&#39;&#39;
        Posts text with stars and space. Best used on dark theme.
        &#39;&#39;&#39;
        await ctx.send(space)

    @commands.command()
    async def textToEmoji(self, ctx: commands.Context, *, text):
        &#39;&#39;&#39;
        Converts text to emoji
        &#39;&#39;&#39;
        await ctx.send(textToEmoji(text))

    @commands.command()
    async def emojiToText(self, ctx: commands.Context, *, text):
        &#39;&#39;&#39;
        Converts emoji to text
        &#39;&#39;&#39;
        await ctx.send(emojiToText(text))

    @commands.command()
    async def fanfic(self, ctx: commands.Context, *, site):
        &#39;&#39;&#39;
        Scrapes text from a webpage with text, and pastes it here
        by Kevinozoid.
        &#39;&#39;&#39;
        await ctx.trigger_typing()

        request = urllib.request.Request(site, None, webscrape_header())
        req = urllib.request.urlopen(request)
        html = req.read()
        soup = BeautifulSoup(html, features=&#34;html.parser&#34;)

        for script in soup([&#34;script&#34;, &#34;style&#34;]):
            script.extract()

        holyText = soup.get_text()

        holyText = &#34;\n&#34;.join([s for s in holyText.splitlines() if s.strip()])

        if len(holyText) &gt; 10000:
            holyText = holyText[:10000]
            await ctx.send(
                &#34;(Text was trimmed to first 10000 characters for being too long.)&#34;)

        paginator = commands.Paginator(prefix=&#34;&#34;, suffix=&#34;&#34;)

        lines = holyText.splitlines()

        lines = [lines[i] for i in range(len(lines))]

        for line in lines:
            paginator.add_line(line)

        for page in paginator.pages:
            await ctx.send(page)
            await asyncio.sleep(1)
        await ctx.send(&#34;**&lt;END OF TEXT&gt;**&#34;)

    @commands.command()
    @commands.guild_only()
    async def timestop(self, ctx: commands.Context, time: int = 5):
        &#39;&#39;&#39;
        Stops time.
        &#39;&#39;&#39;
        # Make a GIF embed of Jotaro saying &#34;STAR PLATINUM ZA WARUDO&#34;
        embed = discord.Embed(
            title=&#34;ZA WARUDO&#34;, colour=discord.Colour.purple())
        embed.set_image(url=(
            &#34;https://media1.tenor.com/images/4b953bf5b5ba531099a823944a5626c2/tenor.gif&#34;))

        await ctx.send(embed=embed, delete_after=1.95)

        # Revoke ability for @everyone to send messages
        current_permissions = ctx.channel.overwrites_for(
            ctx.guild.default_role)
        modified_permissions = discord.PermissionOverwrite.from_pair(
            *current_permissions.pair())
        modified_permissions.send_messages = False
        await ctx.channel.set_permissions(ctx.guild.default_role, overwrite=modified_permissions)

        # Pause while Jotaro gif is playing
        await asyncio.sleep(1.95)

        announcement_msg = await ctx.send(&#34;*Time is frozen*&#34;)

        # Count the seconds in stopped time, but only if the stop time is less
        # than 20s
        if int(time) &lt;= 20:
            for i in range(int(time)):
                await asyncio.sleep(1)
                t = i + 1
                if t == 1:
                    await announcement_msg.edit(content=&#34;1 second has passed&#34;, suppress=False)
                else:
                    await announcement_msg.edit(content=f&#34;{t} seconds have passed&#34;, suppress=False)
        else:
            await asyncio.sleep(int(time) - 2 if int(time) &gt;= 2 else 0)

        # Restore original permissions
        await ctx.channel.set_permissions(ctx.guild.default_role, overwrite=current_permissions)

        await announcement_msg.edit(content=f&#34;*Time has begun to move again.*\n(Time stopped by {ctx.author.mention})&#34;, suppress=False)

        logger.info(ctx.guild,
                    f&#34;Timestop in {ctx.channel.name} lasting {time} seconds&#34;)

    @commands.Cog.listener()
    async def on_message(self, message: discord.Message):
        &#39;&#39;&#39;
        Emoji call listener
        &#39;&#39;&#39;
        if not message.author.bot:
            if message.content.lower()[0:3] == &#34;tte&#34;:
                await self.textToEmoji(await self.bot.get_context(message), text=message.content.lower().lstrip(&#34;tte &#34;))
            elif message.content.lower()[0:3] == &#34;ett&#34;:
                await self.emojiToText(await self.bot.get_context(message), text=message.content.lower().lstrip(&#34;ett &#34;))

            if message.guild and message.content == &#34;STAR PLATINUM&#34;:
                await self.timestop(await self.bot.get_context(message), 5)

    @commands.command()
    async def defaultdance(self, ctx: commands.Context):
        &#39;&#39;&#39;
        Posts Fortnite default dance animation
        &#39;&#39;&#39;
        frames = [frame for frame in fortnite_dance()]

        msg = await ctx.send(f&#34;```{frames[0]}```&#34;)

        for i in range(1, len(frames)):
            await asyncio.sleep(1)
            await msg.edit(content=f&#34;```{frames[i]}```&#34;)

        await asyncio.sleep(10)
        await msg.delete()

    @commands.command(name=&#34;owoify&#34;)
    async def cmdowoify(self, ctx: commands.Context, *, text: str = &#34;&#34;):
        &#39;&#39;&#39;
        changes all R&#39;s and L&#39;s to W&#39;s
        &#39;&#39;&#39;
        t = text.strip()

        if len(t) == 0:
            # owoify previous message
            msg = (await ctx.channel.history(limit=2).flatten())[1]
            auth = msg.author
            t = msg.content
        else:
            auth = ctx.author

        if ctx.guild:
            await echo(ctx, member=auth, content=owoify(t))
        else:
            await ctx.send(owoify(t))

    @commands.command(name=&#34;emojify&#34;)
    @commands.guild_only()
    async def cmdemojify(self, ctx: commands.Context, *, text: str = &#34;&#34;):
        &#39;&#39;&#39;
        adds random emojis in spaces
        &#39;&#39;&#39;
        t = text.strip()

        if len(t) == 0:
            msg = (await ctx.channel.history(limit=2).flatten())[1]
            auth = msg.author
            t = msg.content
        else:
            auth = ctx.author

        await echo(ctx, member=auth, content=emojify(ctx.guild, t))

    @commands.command(name=&#34;mock&#34;)
    async def cmdmock(self, ctx: commands.Context, *, text: str = &#34;&#34;):
        &#39;&#39;&#39;
        randomly capitalizes and lowercases a message
        &#39;&#39;&#39;

        t = text.strip()

        if len(t) == 0:
            msg = (await ctx.channel.history(limit=2).flatten())[1]
            auth = msg.author
            t = msg.content
        else:
            auth = ctx.author

        if ctx.guild:
            await echo(ctx, member=auth, content=mock(t))
        else:
            await ctx.send(mock(t))

    @commands.command()
    @commands.guild_only()
    async def fuckup(self, ctx: commands.Context, *, text: str = &#34;&#34;):
        &#39;&#39;&#39;
        Apply every single effect possible to some text
        &#39;&#39;&#39;
        t = text.strip()
        if len(t) == 0:
            msg = (await ctx.channel.history(limit=2).flatten())[1]
            auth = msg.author
            t = msg.content
        else:
            auth = ctx.author

        await echo(ctx, member=auth,
                   content=owoify(emojify(ctx.guild, mock(t))))

    @commands.command()
    async def futa(self, ctx: commands.Context, m: discord.Message = None):
        &#39;&#39;&#39;
        Developed by Futanari Yaoi.
        Search on Google to learn more about his work
        &#39;&#39;&#39;
        if not m:
            m = (await ctx.channel.history(limit=2).flatten())[1]

        # spell futanari yaoi
        await m.add_reaction(u&#34;\U0001F1EB&#34;)
        await m.add_reaction(u&#34;\U0001F1FA&#34;)
        await m.add_reaction(u&#34;\U0001F1F9&#34;)
        await m.add_reaction(u&#34;\U0001F1E6&#34;)
        await m.add_reaction(u&#34;\U0001F1F3&#34;)
        await m.add_reaction(&#34;üÖ∞Ô∏è&#34;)
        await m.add_reaction(u&#34;\U0001F1F7&#34;)
        await m.add_reaction(u&#34;\U0001F1EE&#34;)

        await m.add_reaction(&#34;‚ñ™Ô∏è&#34;)

        await m.add_reaction(u&#34;\U0001F1FE&#34;)
        await m.add_reaction(&#34;4Ô∏è‚É£&#34;)
        await m.add_reaction(&#34;0Ô∏è‚É£&#34;)
        await m.add_reaction(&#34;‚ÑπÔ∏è&#34;)

        await m.add_reaction(&#34;‚óºÔ∏è&#34;)
        await m.add_reaction(&#34;‚ôÄÔ∏è&#34;)
        await m.add_reaction(&#34;‚ôÇÔ∏è&#34;)
        await m.add_reaction(&#34;üçÜ&#34;)
        await m.add_reaction(&#34;üí¶&#34;)

    @commands.command()
    async def ascii(self, ctx: commands.Context, character: str, *, text):
        &#39;&#39;&#39;
        Sends a big form of a character in word art form. Can use emojis too.
        &#39;&#39;&#39;
        if ctx.guild and (
                e := discord.utils.get(ctx.guild.emojis, name=character)):
            character = str(e)

        letters = {&#34;a&#34;: &#34;###\n#b#\n###\n#b#\n#b#&#34;,
                   &#34;b&#34;: &#34;##b\n#b#\n###\n#b#\n##b&#34;,
                   &#34;c&#34;: &#34;###\n#bb\n#bb\n#bb\n###&#34;,
                   &#34;d&#34;: &#34;##b\n#b#\n#b#\n#b#\n##b&#34;,
                   &#34;e&#34;: &#34;###\n#bb\n###\n#bb\n###&#34;,
                   &#34;f&#34;: &#34;###\n#bb\n###\n#bb\n#bb&#34;,
                   &#34;g&#34;: &#34;b##\n#bb\n#b#\n#b#\nb##&#34;,
                   &#34;h&#34;: &#34;#b#\n#b#\n###\n#b#\n#b#&#34;,
                   &#34;i&#34;: &#34;###\nb#b\nb#b\nb#b\n###&#34;,
                   &#34;j&#34;: &#34;###\nb#b\nb#b\nb#b\n#bb&#34;,
                   &#34;k&#34;: &#34;#bb\n#b#\n#b#\n#b#\n#b#&#34;,
                   &#34;l&#34;: &#34;#bb\n#bb\n#bb\n#bb\n###&#34;,
                   &#34;m&#34;: &#34;#b#\n###\n###\n#b#\n#b#&#34;,
                   &#34;n&#34;: &#34;bbb\nbbb\n##b\n#b#\n#b#&#34;,
                   &#34;o&#34;: &#34;###\n#b#\n#b#\n#b#\n###&#34;,
                   &#34;p&#34;: &#34;###\n#b#\n###\n#bb\n#bb&#34;,
                   &#34;q&#34;: &#34;b#b\n#b#\n#b#\nb##\nbb#&#34;,
                   &#34;r&#34;: &#34;##b\n#b#\n##b\n#b#\n#b#&#34;,
                   &#34;s&#34;: &#34;###\n#bb\n###\nbb#\n###&#34;,
                   &#34;t&#34;: &#34;###\nb#b\nb#b\nb#b\nb#b&#34;,
                   &#34;u&#34;: &#34;#b#\n#b#\n#b#\n#b#\n###&#34;,
                   &#34;v&#34;: &#34;#b#\n#b#\n#b#\n#b#\nb#b&#34;,
                   &#34;w&#34;: &#34;#b#\n#b#\n###\n###\n#b#&#34;,
                   &#34;x&#34;: &#34;#b#\n#b#\nb#b\n#b#\n#b#&#34;,
                   &#34;y&#34;: &#34;#b#\n#b#\nb#b\nb#b\nb#b&#34;,
                   &#34;z&#34;: &#34;###\nbb#\nb#b\n#bb\n###&#34;,
                   &#34; &#34;: &#34;bbb\nbbb\nbbb\nbbb\nbbb&#34;}
        try:
            out = &#34;&#34;

            # TO FIX
            def divide_chunks(lst, n):
                for i in range(0, len(lst), n):
                    yield lst[i:i + n]

            for c in text.lower():
                if c not in letters:
                    raise Exception
                ch = letters[c].replace(
                    &#34;b&#34;, &#34;:black_small_square:&#34;).replace(&#34;#&#34;, character)
                out += ch + &#34;\n\n&#34;

            if len(out) &gt; 2000:
                pg = commands.Paginator(prefix=&#34;&#34;, suffix=&#34;&#34;)

                count_so_far = 0

                for chunk in divide_chunks(out.splitlines(), 6):

                    # start new page if next chunk is too big
                    chunk_length = sum([len(ln) for ln in chunk])

                    if count_so_far + chunk_length &gt; 2000:
                        pg.close_page()
                        count_so_far = 0

                    for line in chunk:
                        pg.add_line(line)

                    count_so_far += chunk_length

                for page in pg.pages:
                    await ctx.send(page)
            else:
                await ctx.send(out)
        except KeyError:
            await ctx.send(&#34;Text must be alphabetical only.&#34;)

    @commands.command()
    async def secret(self, ctx: commands.Context):
        &#39;&#39;&#39;
        Sends all your deepest, darkest secrets into a black hole
        &#39;&#39;&#39;
        try:
            await ctx.message.delete()
        except Exception:
            pass

        await shoujosend(ctx,
                         content=&#34;Don&#39;t worry, your secret is safe with me~ (^_&lt;)„Äú‚òÜ&#34;)

    @commands.command()
    async def sparklify(self, ctx: commands.Context, *, message=None):
        &#39;&#39;&#39;
        makes your message extra kawaii desu~
        functions differently depending on whether you send text or an image
        &#39;&#39;&#39;
        feelings = random.choice(thoughts)
        if &#39;{}&#39; in feelings:
            friend = ctx.message.author.display_name

            shoujo_role_exists = &#39;Shoujotard&#39; in [
                r.name for r in ctx.guild.roles]
            author_has_shoujo_role = shoujo_role_exists and &#39;Shoujotard&#39; in [
                r.name for r in ctx.author.roles]

            # in the case that the Shoujotard role doesn&#39;t exist, call everyone chan
            # Else, only call those who have the Shoujotard role chan
            if (author_has_shoujo_role or not shoujo_role_exists):
                friend += &#39;-chan&#39;
            feelings = feelings.replace(&#39;{}&#39;, friend)

        if message:
            sparkle = random.choice(sparkles)

            sparklyMessage = f&#34;`{sparkle} {message} {sparkle[-1::-1]}`&#34;

            try:
                await ctx.message.delete()
            except BaseException:
                pass
            await shoujosend(ctx, sparklyMessage)

        else:
            f = io.BytesIO()
            await ctx.message.attachments[0].save(f)
            f.seek(0)
            ogImage = Image.open(f)
            size = max(ogImage.size)

            kiraKira = Image.open(&#34;static/sparkle.png&#34;).resize((size, size))
            ogImage.paste(kiraKira, (0, 0), kiraKira)

            f.seek(0)
            ogImage.save(f, &#34;PNG&#34;)
            f.seek(0)

            await shoujosend(ctx, content=feelings,
                             file=discord.File(f, &#39;sparklified.png&#39;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>discord.ext.commands.cog.Cog</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="Comrade.components.fun.fun_cmds.Fun.ascii"><code class="name">var <span class="ident">ascii</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.fun.fun_cmds.Fun.cmdemojify"><code class="name">var <span class="ident">cmdemojify</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.fun.fun_cmds.Fun.cmdmock"><code class="name">var <span class="ident">cmdmock</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.fun.fun_cmds.Fun.cmdowoify"><code class="name">var <span class="ident">cmdowoify</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.fun.fun_cmds.Fun.defaultdance"><code class="name">var <span class="ident">defaultdance</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.fun.fun_cmds.Fun.emojiToText"><code class="name">var <span class="ident">emojiToText</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.fun.fun_cmds.Fun.fanfic"><code class="name">var <span class="ident">fanfic</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.fun.fun_cmds.Fun.fuckup"><code class="name">var <span class="ident">fuckup</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.fun.fun_cmds.Fun.futa"><code class="name">var <span class="ident">futa</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.fun.fun_cmds.Fun.secret"><code class="name">var <span class="ident">secret</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.fun.fun_cmds.Fun.space"><code class="name">var <span class="ident">space</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.fun.fun_cmds.Fun.sparklify"><code class="name">var <span class="ident">sparklify</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.fun.fun_cmds.Fun.textToEmoji"><code class="name">var <span class="ident">textToEmoji</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.fun.fun_cmds.Fun.timestop"><code class="name">var <span class="ident">timestop</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Comrade.components.fun.fun_cmds.Fun.on_message"><code class="name flex">
<span>async def <span class="ident">on_message</span></span>(<span>self, message:¬†discord.message.Message)</span>
</code></dt>
<dd>
<div class="desc"><p>Emoji call listener</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@commands.Cog.listener()
async def on_message(self, message: discord.Message):
    &#39;&#39;&#39;
    Emoji call listener
    &#39;&#39;&#39;
    if not message.author.bot:
        if message.content.lower()[0:3] == &#34;tte&#34;:
            await self.textToEmoji(await self.bot.get_context(message), text=message.content.lower().lstrip(&#34;tte &#34;))
        elif message.content.lower()[0:3] == &#34;ett&#34;:
            await self.emojiToText(await self.bot.get_context(message), text=message.content.lower().lstrip(&#34;ett &#34;))

        if message.guild and message.content == &#34;STAR PLATINUM&#34;:
            await self.timestop(await self.bot.get_context(message), 5)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Comrade.components.fun" href="index.html">Comrade.components.fun</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="Comrade.components.fun.fun_cmds.emojify" href="#Comrade.components.fun.fun_cmds.emojify">emojify</a></code></li>
<li><code><a title="Comrade.components.fun.fun_cmds.fortnite_dance" href="#Comrade.components.fun.fun_cmds.fortnite_dance">fortnite_dance</a></code></li>
<li><code><a title="Comrade.components.fun.fun_cmds.mock" href="#Comrade.components.fun.fun_cmds.mock">mock</a></code></li>
<li><code><a title="Comrade.components.fun.fun_cmds.owoify" href="#Comrade.components.fun.fun_cmds.owoify">owoify</a></code></li>
<li><code><a title="Comrade.components.fun.fun_cmds.shoujosend" href="#Comrade.components.fun.fun_cmds.shoujosend">shoujosend</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Comrade.components.fun.fun_cmds.Fun" href="#Comrade.components.fun.fun_cmds.Fun">Fun</a></code></h4>
<ul class="two-column">
<li><code><a title="Comrade.components.fun.fun_cmds.Fun.ascii" href="#Comrade.components.fun.fun_cmds.Fun.ascii">ascii</a></code></li>
<li><code><a title="Comrade.components.fun.fun_cmds.Fun.cmdemojify" href="#Comrade.components.fun.fun_cmds.Fun.cmdemojify">cmdemojify</a></code></li>
<li><code><a title="Comrade.components.fun.fun_cmds.Fun.cmdmock" href="#Comrade.components.fun.fun_cmds.Fun.cmdmock">cmdmock</a></code></li>
<li><code><a title="Comrade.components.fun.fun_cmds.Fun.cmdowoify" href="#Comrade.components.fun.fun_cmds.Fun.cmdowoify">cmdowoify</a></code></li>
<li><code><a title="Comrade.components.fun.fun_cmds.Fun.defaultdance" href="#Comrade.components.fun.fun_cmds.Fun.defaultdance">defaultdance</a></code></li>
<li><code><a title="Comrade.components.fun.fun_cmds.Fun.emojiToText" href="#Comrade.components.fun.fun_cmds.Fun.emojiToText">emojiToText</a></code></li>
<li><code><a title="Comrade.components.fun.fun_cmds.Fun.fanfic" href="#Comrade.components.fun.fun_cmds.Fun.fanfic">fanfic</a></code></li>
<li><code><a title="Comrade.components.fun.fun_cmds.Fun.fuckup" href="#Comrade.components.fun.fun_cmds.Fun.fuckup">fuckup</a></code></li>
<li><code><a title="Comrade.components.fun.fun_cmds.Fun.futa" href="#Comrade.components.fun.fun_cmds.Fun.futa">futa</a></code></li>
<li><code><a title="Comrade.components.fun.fun_cmds.Fun.on_message" href="#Comrade.components.fun.fun_cmds.Fun.on_message">on_message</a></code></li>
<li><code><a title="Comrade.components.fun.fun_cmds.Fun.secret" href="#Comrade.components.fun.fun_cmds.Fun.secret">secret</a></code></li>
<li><code><a title="Comrade.components.fun.fun_cmds.Fun.space" href="#Comrade.components.fun.fun_cmds.Fun.space">space</a></code></li>
<li><code><a title="Comrade.components.fun.fun_cmds.Fun.sparklify" href="#Comrade.components.fun.fun_cmds.Fun.sparklify">sparklify</a></code></li>
<li><code><a title="Comrade.components.fun.fun_cmds.Fun.textToEmoji" href="#Comrade.components.fun.fun_cmds.Fun.textToEmoji">textToEmoji</a></code></li>
<li><code><a title="Comrade.components.fun.fun_cmds.Fun.timestop" href="#Comrade.components.fun.fun_cmds.Fun.timestop">timestop</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>