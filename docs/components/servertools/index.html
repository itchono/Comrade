<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>Comrade.components.servertools API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Comrade.components.servertools</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .database_tools import Databases
from .emote_system import Emotes
from .user_tools import Users
from .announcements import Announcements
from .vault import Vault
from .moderation import Moderation
from .text_filter import TextFilter
from .message_copier import Copier
from .message_sniper import Sniper

__all__ = [&#34;Databases&#34;, &#34;Emotes&#34;, &#34;Users&#34;,
           &#34;Announcements&#34;, &#34;Vault&#34;, &#34;Moderation&#34;,
           &#34;TextFilter&#34;, &#34;Copier&#34;, &#34;Sniper&#34;]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="Comrade.components.servertools.announcements" href="announcements.html">Comrade.components.servertools.announcements</a></code></dt>
<dd>
<div class="desc"><p>Comrade - Timed announcements</p></div>
</dd>
<dt><code class="name"><a title="Comrade.components.servertools.database_tools" href="database_tools.html">Comrade.components.servertools.database_tools</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="Comrade.components.servertools.emote_system" href="emote_system.html">Comrade.components.servertools.emote_system</a></code></dt>
<dd>
<div class="desc"><p>Emotes exist as 1) Inline Discord Emoji and 2) Big Images
Keep wide images as big emotes, and use small square ones as inline emotes ‚Ä¶</p></div>
</dd>
<dt><code class="name"><a title="Comrade.components.servertools.message_copier" href="message_copier.html">Comrade.components.servertools.message_copier</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="Comrade.components.servertools.message_sniper" href="message_sniper.html">Comrade.components.servertools.message_sniper</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="Comrade.components.servertools.moderation" href="moderation.html">Comrade.components.servertools.moderation</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="Comrade.components.servertools.server_activity" href="server_activity.html">Comrade.components.servertools.server_activity</a></code></dt>
<dd>
<div class="desc"><p>Experimental file ‚Ä¶</p></div>
</dd>
<dt><code class="name"><a title="Comrade.components.servertools.text_filter" href="text_filter.html">Comrade.components.servertools.text_filter</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="Comrade.components.servertools.user_tools" href="user_tools.html">Comrade.components.servertools.user_tools</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="Comrade.components.servertools.vault" href="vault.html">Comrade.components.servertools.vault</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Comrade.components.servertools.Announcements"><code class="flex name class">
<span>class <span class="ident">Announcements</span></span>
<span>(</span><span>bot)</span>
</code></dt>
<dd>
<div class="desc"><p>Add timed announcements, delivered in the announcements channel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Announcements(commands.Cog):
    &#39;&#39;&#39;
    Add timed announcements, delivered in the announcements channel
    &#39;&#39;&#39;

    def __init__(self, bot):
        self.bot: commands.Bot = bot
        self.announcements = {}

        self.timedannounce.start()

    def cog_unload(self):
        self.timedannounce.cancel()

    async def dailyannounce(self, channel: discord.TextChannel):
        &#39;&#39;&#39;
        Daily announcement
        &#39;&#39;&#39;
        m = await channel.send(&#34;Good morning everyone! Today is &#34;
                               f&#34;{local_time().strftime(&#39;%A, %B %d (Day %j in %Y). Time is %I:%M %p %Z&#39;)}. Have a great day.&#34;)
        &#39;&#39;&#39;
        Daily user
        &#39;&#39;&#39;
        ctx = await self.bot.get_context(m)

        if luckyperson := channel.guild.get_member(
                await weighted_member_from_server(channel.guild)):

            collection(&#34;users&#34;).update_one(
                ufil(luckyperson),
                {&#34;$inc&#34;: {&#34;daily-weight&#34;: -1}})

            dailyrole = await role(channel.guild, &#34;Member of the Day&#34;)

            for m in dailyrole.members:
                # remove bearer of previous daily role
                roles = m.roles
                roles.remove(dailyrole)
                await m.edit(roles=roles)
            roles = luckyperson.roles
            roles.append(dailyrole)
            await luckyperson.edit(roles=roles)

            await channel.send(
                f&#34;Today&#39;s Daily Member is **{luckyperson.display_name}**&#34;)

            general_cog = self.bot.get_cog(&#34;General&#34;)
            await general_cog.avatar(ctx, member=luckyperson)

            if not sum_of_weights(channel.guild):
                # rebuild if necessary
                await rebuild_weight_table(channel.guild)

    @tasks.loop(minutes=1.0)
    async def timedannounce(self):
        &#39;&#39;&#39;
        Makes an announcement
        &#39;&#39;&#39;
        servers = collection(&#34;servers&#34;).find()

        now = local_time()

        for s in servers:
            try:
                for a in self.announcements[s[&#34;_id&#34;]]:

                    if (now.strftime(&#34;%H:%M&#34;) == a[&#34;time&#34;]):
                        c = self.bot.get_channel(
                            s[&#34;channels&#34;][&#34;announcements&#34;])

                        if c:
                            # daily announce
                            if hasattr(a[&#34;announcement&#34;], &#34;__call__&#34;):
                                await a[&#34;announcement&#34;](c)
                            else:
                                await c.send(a[&#34;announcement&#34;])
            except Exception:
                pass

    @timedannounce.before_loop
    async def build_announcement_cache(self):
        await self.bot.wait_until_ready()
        for g in self.bot.guilds:
            additonal_announcements = [
                {&#34;server&#34;: g.id, &#34;time&#34;: &#34;08:00&#34;,
                 &#34;announcement&#34;: self.dailyannounce, &#34;owner&#34;: None}]

            if d := collection(&#34;announcements&#34;).find({&#34;server&#34;: g.id}):
                self.announcements[g.id] = list(d) + additonal_announcements
            else:
                self.announcements[g.id] = additonal_announcements

    @commands.command()
    @commands.guild_only()
    async def addannounce(self, ctx: commands.Context, time, *, message):
        &#39;&#39;&#39;
        Adds an announcement to the announcement system [24 hr time].
        Each user is allowed to have a maximum of one announcement.
        &#39;&#39;&#39;
        announce = {
            &#34;server&#34;: ctx.guild.id,
            &#34;time&#34;: time, &#34;announcement&#34;: message, &#34;owner&#34;: ctx.author.id}

        collection(&#34;announcements&#34;).update_one(
            {&#34;server&#34;: ctx.guild.id,
             &#34;owner&#34;: ctx.author.id}, announce, upsert=True)

        await reactOK(ctx)
        await self.build_announcement_cache()  # rebuild cache

    @commands.command()
    @commands.guild_only()
    async def removeannounce(self, ctx: commands.Context, time, *, message):
        &#39;&#39;&#39;
        Removes an announcement from the announcement system
        &#39;&#39;&#39;
        collection(&#34;announcements&#34;).delete_one(
            {&#34;server&#34;: ctx.guild.id, &#34;owner&#34;: ctx.author.id})
        await reactOK(ctx)
        await self.build_announcement_cache()  # rebuild cache

    @commands.command()
    @commands.check_any(commands.is_owner(), isServerOwner())
    @commands.guild_only()
    async def testannounce(self, ctx: commands.Context, time):
        &#39;&#39;&#39;
        Tests making an announcement
        &#39;&#39;&#39;
        for a in self.announcements[ctx.guild.id]:

            if (time == a[&#34;time&#34;]):
                c = ctx.guild.get_channel(
                    collection(&#34;servers&#34;).find_one(
                        ctx.guild.id)[&#34;channels&#34;][&#34;announcements&#34;])

                if hasattr(a[&#34;announcement&#34;], &#34;__call__&#34;):
                    await a[&#34;announcement&#34;](c)  # daily announce

                else:
                    await c.send(a[&#34;announcement&#34;])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>discord.ext.commands.cog.Cog</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="Comrade.components.servertools.Announcements.addannounce"><code class="name">var <span class="ident">addannounce</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.servertools.Announcements.removeannounce"><code class="name">var <span class="ident">removeannounce</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.servertools.Announcements.testannounce"><code class="name">var <span class="ident">testannounce</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Comrade.components.servertools.Announcements.build_announcement_cache"><code class="name flex">
<span>async def <span class="ident">build_announcement_cache</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@timedannounce.before_loop
async def build_announcement_cache(self):
    await self.bot.wait_until_ready()
    for g in self.bot.guilds:
        additonal_announcements = [
            {&#34;server&#34;: g.id, &#34;time&#34;: &#34;08:00&#34;,
             &#34;announcement&#34;: self.dailyannounce, &#34;owner&#34;: None}]

        if d := collection(&#34;announcements&#34;).find({&#34;server&#34;: g.id}):
            self.announcements[g.id] = list(d) + additonal_announcements
        else:
            self.announcements[g.id] = additonal_announcements</code></pre>
</details>
</dd>
<dt id="Comrade.components.servertools.Announcements.cog_unload"><code class="name flex">
<span>def <span class="ident">cog_unload</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A special method that is called when the cog gets removed.</p>
<p>This function <strong>cannot</strong> be a coroutine. It must be a regular
function.</p>
<p>Subclasses must replace this if they want special unloading behaviour.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cog_unload(self):
    self.timedannounce.cancel()</code></pre>
</details>
</dd>
<dt id="Comrade.components.servertools.Announcements.dailyannounce"><code class="name flex">
<span>async def <span class="ident">dailyannounce</span></span>(<span>self, channel:¬†discord.channel.TextChannel)</span>
</code></dt>
<dd>
<div class="desc"><p>Daily announcement</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def dailyannounce(self, channel: discord.TextChannel):
    &#39;&#39;&#39;
    Daily announcement
    &#39;&#39;&#39;
    m = await channel.send(&#34;Good morning everyone! Today is &#34;
                           f&#34;{local_time().strftime(&#39;%A, %B %d (Day %j in %Y). Time is %I:%M %p %Z&#39;)}. Have a great day.&#34;)
    &#39;&#39;&#39;
    Daily user
    &#39;&#39;&#39;
    ctx = await self.bot.get_context(m)

    if luckyperson := channel.guild.get_member(
            await weighted_member_from_server(channel.guild)):

        collection(&#34;users&#34;).update_one(
            ufil(luckyperson),
            {&#34;$inc&#34;: {&#34;daily-weight&#34;: -1}})

        dailyrole = await role(channel.guild, &#34;Member of the Day&#34;)

        for m in dailyrole.members:
            # remove bearer of previous daily role
            roles = m.roles
            roles.remove(dailyrole)
            await m.edit(roles=roles)
        roles = luckyperson.roles
        roles.append(dailyrole)
        await luckyperson.edit(roles=roles)

        await channel.send(
            f&#34;Today&#39;s Daily Member is **{luckyperson.display_name}**&#34;)

        general_cog = self.bot.get_cog(&#34;General&#34;)
        await general_cog.avatar(ctx, member=luckyperson)

        if not sum_of_weights(channel.guild):
            # rebuild if necessary
            await rebuild_weight_table(channel.guild)</code></pre>
</details>
</dd>
<dt id="Comrade.components.servertools.Announcements.timedannounce"><code class="name flex">
<span>def <span class="ident">timedannounce</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>A background task helper that abstracts the loop and reconnection logic for you.</p>
<p>The main interface to create this is through :func:<code>loop</code>.</p></div>
</dd>
</dl>
</dd>
<dt id="Comrade.components.servertools.Copier"><code class="flex name class">
<span>class <span class="ident">Copier</span></span>
<span>(</span><span>bot)</span>
</code></dt>
<dd>
<div class="desc"><p>Copies messages from one channel to another channel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Copier(commands.Cog):
    &#39;&#39;&#39;
    Copies messages from one channel to another channel
    &#39;&#39;&#39;

    def __init__(self, bot):
        self.bot: commands.Bot = bot

    @commands.command()
    @commands.guild_only()
    @commands.check_any(commands.is_owner(), isServerOwner())
    async def copymessages(self, ctx: commands.Context,
                           source: discord.TextChannel,
                           destination: discord.TextChannel):
        &#39;&#39;&#39;
        Exports channel texts to another channel
        &#39;&#39;&#39;
        await ctx.send(f&#34;{ctx.author.mention}, you are about to start a transfer from {source.mention} to {destination.mention}. **THIS IS A POTENTIALLY DESTRUCTIVE ACTION**. Please type `confirm` with the next 60 seconds to continue.&#34;)

        def check(m):
            return m.content == &#39;confirm&#39; and m.channel == ctx.channel and m.author == ctx.author

        try:
            await self.bot.wait_for(&#39;message&#39;, timeout=60.0, check=check)

            await ctx.send(f&#34;Transfer from {source.mention} to {destination.mention} is in progress. This will take several minutes depending on the size of the channel.&#34;)

            webhook = None
            for wh in await destination.webhooks():
                if wh.name == &#34;ChannelCopier&#34;:
                    webhook = wh
            if not webhook:
                webhook = await destination.create_webhook(name=&#34;ChannelCopier&#34;, avatar=None)

            async for message in source.history(limit=None, oldest_first=True):
                m = await webhook.send(wait=True, content=message.content, username=message.author.display_name, avatar_url=message.author.avatar_url, embeds=message.embeds, files=[await a.to_file() for a in message.attachments])
                for r in message.reactions:
                    await m.add_reaction(r)

        except asyncio.TimeoutError:
            await ctx.send(&#34;Tranfer aborted.&#34;)
        else:
            await ctx.send(
                f&#34;Transfer from {source.mention} to {destination.mention} completed successfully.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>discord.ext.commands.cog.Cog</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="Comrade.components.servertools.Copier.copymessages"><code class="name">var <span class="ident">copymessages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="Comrade.components.servertools.Databases"><code class="flex name class">
<span>class <span class="ident">Databases</span></span>
<span>(</span><span>bot)</span>
</code></dt>
<dd>
<div class="desc"><p>Server-side configuration of Comrade's Databases.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Databases(commands.Cog):
    &#39;&#39;&#39;
    Server-side configuration of Comrade&#39;s Databases.
    &#39;&#39;&#39;

    def __init__(self, bot):
        self.bot: commands.Bot = bot

    @commands.command()
    @commands.check_any(commands.is_owner(), isServerOwner())
    @commands.guild_only()
    async def setchannel(self, ctx: commands.Context,
                         channel_name: str,
                         channel: typing.Union[
                             discord.TextChannel,
                             discord.CategoryChannel] = None):
        &#39;&#39;&#39;
        Sets a channel with the given name into the Database.
        Leave channel blank to unset (delete)
        &#39;&#39;&#39;
        if channel_name not in [&#34;vault&#34;, &#34;announcements&#34;, &#34;custom&#34;]:
            await reactX(ctx)
            return

        try:
            if channel:
                collection(&#34;servers&#34;).update_one(
                    {&#34;_id&#34;: ctx.guild.id},
                    {&#34;$set&#34;: {f&#34;channels.{channel_name}&#34;: channel.id}})

            else:
                collection(&#34;servers&#34;).update_one(
                    {&#34;_id&#34;: ctx.guild.id},
                    {&#34;$set&#34;: {f&#34;channels.{channel_name}&#34;: 0}})
        except Exception as ex:
            await ctx.send(f&#34;Error: {ex}&#34;)
            return

        await reactOK(ctx)

    @commands.command()
    @commands.check_any(commands.is_owner(), isServerOwner())
    @commands.guild_only()
    async def channelmappings(self, ctx: commands.Context):
        &#39;&#39;&#39;
        View database channel mappings
        &#39;&#39;&#39;
        server_cfg = collection(&#34;servers&#34;).find_one({&#34;_id&#34;: ctx.guild.id})

        s = &#34;&#34;

        for channel_name in server_cfg[&#34;channels&#34;]:
            if channel := self.bot.get_channel(
                    server_cfg[&#34;channels&#34;][channel_name]):
                s += f&#34;{channel_name}: {channel.mention}\n&#34;
            else:
                s += f&#34;{channel_name}: Unassigned\n&#34;

        await ctx.send(s)

    @commands.group(name=&#34;cfg&#34;, aliases=[&#34;config&#34;, &#34;set&#34;])
    @commands.check_any(commands.is_owner(), isServerOwner())
    @commands.guild_only()
    async def configure(self, ctx: commands.Context):
        &#39;&#39;&#39;
        Alters configuration settings
        &#39;&#39;&#39;
        if ctx.invoked_subcommand is None:
            await ctx.send(&#34;These operations are quite dangerous.&#34;
                           &#34;Proceed with caution.&#34;)

    @configure.command()
    @commands.check_any(commands.is_owner(), isServerOwner())
    @commands.guild_only()
    async def user(self, ctx: commands.Context,
                   member: discord.Member, index: str, value=None):
        &#39;&#39;&#39;
        Modifies a value in the user database.
        Leave value as none to delete field.
        Access nested fields using dot notation
        ex. {&#34;sandwich&#34;: {&#34;bread&#34;:rye}}
        &gt;&gt;&gt; &#34;sandwich.bread&#34; would be the index
        &#39;&#39;&#39;

        if value is None:
            try:
                collection(&#34;users&#34;).update_one(
                    ufil(member),
                    {&#34;$unset&#34;: {index: &#34;&#34;}}
                )
            except Exception as ex:
                await ctx.send(f&#34;Error: {ex}&#34;)

        else:
            try:
                collection(&#34;users&#34;).update_one(
                    ufil(member),
                    {&#34;$set&#34;: {index: literal_eval(value)}}
                )
            except Exception as ex:
                await ctx.send(f&#34;Error: {ex}&#34;)

        await reactOK(ctx)

    @configure.command()
    @commands.check_any(commands.is_owner(), isServerOwner())
    @commands.guild_only()
    async def allusers(self, ctx: commands.Context,
                       index: str, value=None):
        &#39;&#39;&#39;
        Modifies a value in every user&#39;s config in this server.
        Leave value as none to delete field.
        Access nested fields using dot notation
        ex. {&#34;sandwich&#34;: {&#34;bread&#34;:rye}}
        &gt;&gt;&gt; &#34;sandwich.bread&#34; would be the index
        &#39;&#39;&#39;

        if value is None:
            try:
                collection(&#34;users&#34;).update_many(
                    {&#34;server&#34;: ctx.guild.id},
                    {&#34;$unset&#34;: {index: &#34;&#34;}}
                )
            except Exception as ex:
                await ctx.send(f&#34;Error: {ex}&#34;)

        else:
            try:
                collection(&#34;users&#34;).update_many(
                    {&#34;server&#34;: ctx.guild.id},
                    {&#34;$set&#34;: {index: literal_eval(value)}}
                )
            except Exception as ex:
                await ctx.send(f&#34;Error: {ex}&#34;)

        await reactOK(ctx)

    @configure.command()
    @commands.check_any(commands.is_owner(), isServerOwner())
    @commands.guild_only()
    async def server(self, ctx: commands.Context,
                     index: str, value=None):
        &#39;&#39;&#39;
        Modifies a value in the server database.
        Leave value as none to delete field.
        Access nested fields using dot notation
        ex. {&#34;sandwich&#34;: {&#34;bread&#34;:rye}}
        &gt;&gt;&gt; &#34;sandwich.bread&#34; would be the index
        &#39;&#39;&#39;

        if value is None:
            try:
                collection(&#34;servers&#34;).update_one(
                    {&#34;_id&#34;: ctx.guild.id},
                    {&#34;$unset&#34;: {index: &#34;&#34;}}
                )
            except Exception as ex:
                await ctx.send(f&#34;Error: {ex}&#34;)

        else:
            try:
                collection(&#34;servers&#34;).update_one(
                    {&#34;_id&#34;: ctx.guild.id},
                    {&#34;$set&#34;: {index: literal_eval(value)}}
                )
            except Exception as ex:
                await ctx.send(f&#34;Error: {ex}&#34;)

        await reactOK(ctx)

    @commands.Cog.listener()
    async def on_guild_join(self, guild: discord.Guild):
        &#39;&#39;&#39;
        When the bot joins a server.
        &#39;&#39;&#39;
        collection(&#34;servers&#34;).insert_one(new_server(guild))
        rebuild_user_profiles(guild)
        # Add new server entry

    @commands.Cog.listener()
    async def on_guild_remove(self, guild: discord.Guild):
        &#39;&#39;&#39;
        When the bot leaves a server.
        &#39;&#39;&#39;
        collection(&#34;servers&#34;).delete_one({&#34;_id&#34;: guild.id})
        collection(&#34;users&#34;).delete_many({&#34;server&#34;: guild.id})</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>discord.ext.commands.cog.Cog</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="Comrade.components.servertools.Databases.allusers"><code class="name">var <span class="ident">allusers</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.servertools.Databases.channelmappings"><code class="name">var <span class="ident">channelmappings</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.servertools.Databases.configure"><code class="name">var <span class="ident">configure</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.servertools.Databases.server"><code class="name">var <span class="ident">server</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.servertools.Databases.setchannel"><code class="name">var <span class="ident">setchannel</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.servertools.Databases.user"><code class="name">var <span class="ident">user</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Comrade.components.servertools.Databases.on_guild_join"><code class="name flex">
<span>async def <span class="ident">on_guild_join</span></span>(<span>self, guild:¬†discord.guild.Guild)</span>
</code></dt>
<dd>
<div class="desc"><p>When the bot joins a server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@commands.Cog.listener()
async def on_guild_join(self, guild: discord.Guild):
    &#39;&#39;&#39;
    When the bot joins a server.
    &#39;&#39;&#39;
    collection(&#34;servers&#34;).insert_one(new_server(guild))
    rebuild_user_profiles(guild)</code></pre>
</details>
</dd>
<dt id="Comrade.components.servertools.Databases.on_guild_remove"><code class="name flex">
<span>async def <span class="ident">on_guild_remove</span></span>(<span>self, guild:¬†discord.guild.Guild)</span>
</code></dt>
<dd>
<div class="desc"><p>When the bot leaves a server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@commands.Cog.listener()
async def on_guild_remove(self, guild: discord.Guild):
    &#39;&#39;&#39;
    When the bot leaves a server.
    &#39;&#39;&#39;
    collection(&#34;servers&#34;).delete_one({&#34;_id&#34;: guild.id})
    collection(&#34;users&#34;).delete_many({&#34;server&#34;: guild.id})</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Comrade.components.servertools.Emotes"><code class="flex name class">
<span>class <span class="ident">Emotes</span></span>
<span>(</span><span>bot)</span>
</code></dt>
<dd>
<div class="desc"><p>Add or remove emotes.
Use :emotename: to call an emote
Use /emotename/ to swap its type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Emotes(commands.Cog):
    &#39;&#39;&#39;
    Add or remove emotes.
    Use :emotename: to call an emote
    Use /emotename/ to swap its type
    &#39;&#39;&#39;

    def __init__(self, bot):
        self.bot: commands.Bot = bot

    @commands.group(invoke_without_command=True)
    @commands.guild_only()
    async def emote(self, ctx: commands.Context, e: str):
        &#39;&#39;&#39;
        Sends an emote into a context, injecting first if necessary

        Subcommands: add, remove, rename
        &#39;&#39;&#39;
        if ctx.invoked_subcommand is None:

            # Stage 1: Search server cache
            if emote := discord.utils.get(ctx.guild.emojis, name=e):
                await echo(ctx, member=ctx.author, content=emote)
                await ctx.message.delete()  # try to delete

            # Stage 2: Search MongoDB
            elif (document := collection(&#34;emotes&#34;).find_one({&#34;name&#34;: e, &#34;server&#34;: ctx.guild.id})) or \
                    (document := collection(&#34;emotes&#34;).find_one(
                        {&#34;name&#34;: re.compile(&#39;^&#39; + e + &#39;$&#39;, re.IGNORECASE),
                         &#34;server&#34;: ctx.guild.id})):

                # 2A: inline emoji,
                # maybe they just can&#39;t spell
                if emote := discord.utils.get(
                        ctx.guild.emojis, name=document[&#34;name&#34;]):
                    await echo(ctx, member=ctx.author, content=emote)
                    await ctx.message.delete()  # try to delete

                # Or, it needs to be added
                elif document[&#34;type&#34;] == &#34;inline&#34;:
                    emote = await inject(ctx, document[&#34;name&#34;])
                    await echo(ctx, member=ctx.author, content=emote)
                    await ctx.message.delete()  # try to delete

                # 2B: Big emoji, send as-is
                elif document[&#34;type&#34;] == &#34;big&#34;:
                    eb = discord.Embed()
                    eb.set_image(url=document[&#34;URL&#34;])
                    if len(e) &gt; 32:
                        e = e[:32]
                    await mimic(ctx.channel,
                                embed=eb,
                                avatar_url=ctx.author.avatar_url,
                                username=e)

    @emote.command()
    @commands.guild_only()
    async def add(self, ctx: commands.Context, name: str, url=None):
        &#39;&#39;&#39;
        Adds a custom emote to the Comrade Emote System.
        Adds as a big emote by default.
        &#39;&#39;&#39;
        try:
            if not url:
                url = ctx.message.attachments[0].url
        except BaseException:
            if not is_url(url):
                await ctx.send(&#34;Invalid URL Provided.&#34;)
                return

        # Validate Name
        if not name.isalnum():
            await ctx.send(&#34;Name must be alphanumeric!&#34;)
            return
        elif len(name) &gt; 32:
            await ctx.send(&#34;Max Name Length is 32 Chars.&#34;)
            return

        # make sure it doesn&#39;t already exist
        if not collection(&#34;emotes&#34;).find_one(
                {&#34;name&#34;: name, &#34;server&#34;: ctx.guild.id}):
            await ctx.trigger_typing()

            # upload as big by default
            await upload(ctx, name, url, &#34;big&#34;)

            await ctx.send(f&#39;Emote `{name}` was added. &#39;
                           f&#39;you can call it using `:{name}:`&#39;)

        else:
            await reactX(ctx)
            await ctx.send(f&#39;Emote `{name}` already exists! &#39;
                           &#39;Contact a mod to get this fixed.&#39;)

    @emote.command()
    @commands.check(isOP())
    @commands.guild_only()
    async def remove(self, ctx: commands.Context, name):
        &#39;&#39;&#39;
        Removes a custom emote from the Comrade Emote System
        &#39;&#39;&#39;
        if e := collection(&#34;emotes&#34;).find_one(
                {&#34;name&#34;: name, &#34;server&#34;: ctx.guild.id}):

            try:
                blob = storage.Blob(
                    f&#34;{ctx.guild.id}{name}.{e[&#39;ext&#39;]}&#34;, gc_bucket())
                blob.delete()
            except BaseException:
                pass

            collection(&#34;emotes&#34;).delete_one(
                {&#34;name&#34;: name, &#34;server&#34;: ctx.guild.id})
            await ctx.send(f&#34;Emote `{name}` was removed.&#34;)

            if e[&#34;type&#34;] == &#34;inline&#34;:
                emote = discord.utils.get(ctx.guild.emojis, name=name)
                try:
                    await emote.delete(reason=&#34;Unloading emoji because &#34;
                                       &#34;it was removed from the server.&#34;)
                except BaseException:
                    pass
        else:
            await ctx.send(f&#34;Emote `{name}` was not found.&#34;)

    @emote.command()
    @commands.guild_only()
    async def rename(self, ctx: commands.Context, name_old, name_new):
        &#39;&#39;&#39;
        Renames an emote in the emote system
        &#39;&#39;&#39;
        if collection(&#34;emotes&#34;).update_one(
                {&#34;name&#34;: name_old, &#34;server&#34;: ctx.guild.id},
                {&#34;$set&#34;: {&#34;name&#34;: name_new}}):
            await ctx.send(f&#34;Emote `{name_old}` was renamed.&#34;)

            if e := collection(&#34;emotes&#34;).find_one(
                {&#34;name&#34;: name_old, &#34;server&#34;: ctx.guild.id}):

                if e[&#34;type&#34;] == &#34;inline&#34;:
                    emote = discord.utils.get(ctx.guild.emojis, name=name_old)
                    try:
                        await emote.edit(name = name_new)
                    except BaseException:
                        pass
        else:
            await ctx.send(f&#34;Emote `{name_old}` was not found.&#34;)

    @emote.command()
    @commands.guild_only()
    async def gallery(self, ctx: commands.Context, start_position: int = 1):
        &#39;&#39;&#39;
        Gallery of all big emotes in server
        Can specify starting position to skip ahead
        &#39;&#39;&#39;
        bigemotes = collection(&#34;emotes&#34;).find(
            {&#34;server&#34;: ctx.guild.id, &#34;type&#34;: &#34;big&#34;}).sort(
                &#34;name&#34;, 1)

        if not bigemotes:
            return  # empty
        bigemotes = list(bigemotes)

        pagenum = start_position-1

        def em_embed(pagenum):
            e = discord.Embed(color=0xd7342a)
            e.set_author(name=bigemotes[pagenum][&#34;name&#34;],
                         url=bigemotes[pagenum][&#34;URL&#34;])
            e.set_image(url=bigemotes[pagenum][&#34;URL&#34;])
            e.set_footer(text=f&#34;{pagenum+1}/{len(bigemotes)}&#34;)
            return e

        m = await ctx.send(embed=em_embed(pagenum))

        cont = True

        for r in [&#34;‚¨Ö&#34;, &#34;‚û°&#34;, &#34;‚è™&#34;, &#34;‚è©&#34;, &#34;üóëÔ∏è&#34;]:
            await m.add_reaction(r)

        def check(reaction, user):
            return str(reaction) in [
                &#34;‚¨Ö&#34;, &#34;‚û°&#34;, &#34;‚è™&#34;, &#34;‚è©&#34;, &#34;üóëÔ∏è&#34;] and reaction.message.id == m.id \
                    and not user.bot

        BIGSTEP = round(len(bigemotes)/10)

        while cont:
            try:
                reaction, user = await self.bot.wait_for(
                    &#34;reaction_add&#34;, check=check, timeout=180)

                await m.remove_reaction(reaction, user)
                if str(reaction) == &#34;‚¨Ö&#34;:
                    pagenum -= 1
                    if pagenum &lt; 0:
                        pagenum += len(bigemotes)

                elif str(reaction) == &#34;‚û°&#34;:
                    pagenum += 1
                    if pagenum &gt;= len(bigemotes):
                        pagenum -= len(bigemotes)

                elif str(reaction) == &#34;‚è©&#34;:
                    pagenum += BIGSTEP
                    if pagenum &gt;= len(bigemotes):
                        pagenum -= len(bigemotes)

                elif str(reaction) == &#34;‚è™&#34;:
                    pagenum -= BIGSTEP
                    if pagenum &lt; 0:
                        pagenum += len(bigemotes)

                elif str(reaction) == &#34;üóëÔ∏è&#34;:
                    await m.delete()
                    cont = False
                    continue
                
                await m.edit(embed=em_embed(pagenum))
            except asyncio.TimeoutError:
                await m.delete()
                cont = False
                continue

    @emote.group()
    @commands.guild_only()
    async def list(self, ctx: commands.Context):
        if ctx.invoked_subcommand is None:
            await ctx.send(f&#34;Run `{bot_prefix}emote list big` or &#34;
                           f&#34;`{bot_prefix}emote list inline` to see a list &#34;
                           &#34;or big and inline emotes respectively&#34;)

    @list.command()
    @commands.guild_only()
    async def big(self, ctx: commands.Context, page=1):
        &#39;&#39;&#39;
        Lists all big emotes in the server, based on page
        &#39;&#39;&#39;
        paginator = commands.Paginator(prefix=&#34;&#34;, suffix=&#34;&#34;, max_size=200)

        bigemotes = collection(&#34;emotes&#34;).find(
            {&#34;server&#34;: ctx.guild.id, &#34;type&#34;: &#34;big&#34;}, {&#34;name&#34;: True}).sort(
                &#34;name&#34;, 1)

        if not bigemotes:
            return  # empty

        for i in bigemotes:
            paginator.add_line(f&#34;- {i[&#39;name&#39;]}&#34;)

        pagenum = 1

        pages = paginator.pages

        m = await ctx.send(f&#34;__**Big Emotes in {ctx.guild.name} &#34;
                           f&#34;({pagenum}/{len(pages)})**__:{pages[pagenum-1]}&#34;)

        cont = True

        for r in [&#34;‚¨Ö&#34;, &#34;‚û°&#34;, &#34;‚è™&#34;, &#34;‚è©&#34;, &#34;üóëÔ∏è&#34;]:
            await m.add_reaction(r)

        def check(reaction, user):
            return str(reaction) in [
                &#34;‚¨Ö&#34;, &#34;‚û°&#34;, &#34;‚è™&#34;, &#34;‚è©&#34;, &#34;üóëÔ∏è&#34;] and reaction.message.id == m.id \
                    and not user.bot

        BIGSTEP = round(len(pages)/5)

        while cont:
            try:
                reaction, user = await self.bot.wait_for(
                    &#34;reaction_add&#34;, check=check, timeout=180)

                await m.remove_reaction(reaction, user)
                if str(reaction) == &#34;‚¨Ö&#34;:
                    pagenum -= 1

                    if pagenum &lt; 1:
                        pagenum += len(pages) - 1

                elif str(reaction) == &#34;‚è™&#34;:
                    pagenum -= BIGSTEP

                    if pagenum &lt; 1:
                        pagenum += len(pages) - 1

                elif str(reaction) == &#34;‚û°&#34;:
                    pagenum += 1
                    if pagenum &gt;= len(pages):
                        pagenum -= len(pages) - 1

                elif str(reaction) == &#34;‚è©&#34;:
                    pagenum += BIGSTEP
                    if pagenum &gt;= len(pages):
                        pagenum -= len(pages) - 1

                elif str(reaction) == &#34;üóëÔ∏è&#34;:
                    await m.delete()
                    cont = False
                    continue

                await m.edit(content=f&#34;__**Big Emotes in {ctx.guild.name} &#34;
                             f&#34;({pagenum}/{len(pages)})**__:{pages[pagenum-1]}&#34;)

            except asyncio.TimeoutError:
                cont = False
                continue

    @list.command()
    @commands.guild_only()
    async def inline(self, ctx: commands.Context, page=1):
        &#39;&#39;&#39;
        Lists all inline emotes in the server, based on page.
        This may not include all inline emoji,
        especially if the bot was recently added to the server.
        &#39;&#39;&#39;
        paginator = commands.Paginator(prefix=&#34;&#34;, suffix=&#34;&#34;, max_size=200)

        inlineemotes = collection(&#34;emotes&#34;).find(
            {&#34;server&#34;: ctx.guild.id, &#34;type&#34;: &#34;inline&#34;}, {&#34;name&#34;: True}).sort(
                &#34;name&#34;, 1)

        if not inlineemotes:
            return  # empty

        for i in inlineemotes:
            paginator.add_line(f&#34;- {i[&#39;name&#39;]}&#34;)

        pagenum = 1

        pages = paginator.pages

        m = await ctx.send(f&#34;__**Inline Emotes in {ctx.guild.name} ({pagenum}/{len(pages)})**__:{pages[pagenum-1]}&#34;)

        cont = True

        for r in [&#34;‚¨Ö&#34;, &#34;‚û°&#34;, &#34;‚è™&#34;, &#34;‚è©&#34;, &#34;üóëÔ∏è&#34;]:
            await m.add_reaction(r)

        def check(reaction, user):
           return str(reaction) in [
                &#34;‚¨Ö&#34;, &#34;‚û°&#34;, &#34;‚è™&#34;, &#34;‚è©&#34;, &#34;üóëÔ∏è&#34;] and reaction.message.id == m.id \
                    and not user.bot

        BIGSTEP = round(len(pages)/5)

        while cont:
            try:
                reaction, user = await self.bot.wait_for(&#34;reaction_add&#34;, check=check, timeout=180)

                await m.remove_reaction(reaction, user)

                if str(reaction) == &#34;‚¨Ö&#34;:
                    pagenum -= 1

                    if pagenum &lt; 1:
                        pagenum += len(pages) - 1

                elif str(reaction) == &#34;‚è™&#34;:
                    pagenum -= BIGSTEP

                    if pagenum &lt; 1:
                        pagenum += len(pages) - 1

                elif str(reaction) == &#34;‚û°&#34;:
                    pagenum += 1
                    if pagenum &gt;= len(pages):
                        pagenum -= len(pages) - 1

                elif str(reaction) == &#34;‚è©&#34;:
                    pagenum += BIGSTEP
                    if pagenum &gt;= len(pages):
                        pagenum -= len(pages) - 1

                elif str(reaction) == &#34;üóëÔ∏è&#34;:
                    await m.delete()
                    cont = False
                    continue

                await m.edit(content=f&#34;__**Inline Emotes in {ctx.guild.name} ({pagenum}/{len(pages)})**__:{pages[pagenum-1]}&#34;)
            except asyncio.TimeoutError:
                cont = False
                continue

    @commands.command()
    @commands.guild_only()
    async def swaptype(self, ctx: commands.Context, name):
        &#39;&#39;&#39;
        Swaps the type of the emote
        &#39;&#39;&#39;
        if (document := collection(&#34;emotes&#34;).find_one({&#34;name&#34;: name, &#34;server&#34;: ctx.guild.id})) or (document := collection(
                &#34;emotes&#34;).find_one({&#34;name&#34;: re.compile(&#39;^&#39; + name + &#39;$&#39;, re.IGNORECASE), &#34;server&#34;: ctx.guild.id})):
            # in mongodb already; most routine change

            newtype = {&#34;big&#34;: &#34;inline&#34;, &#34;inline&#34;: &#34;big&#34;}[document[&#34;type&#34;]]

            if document[&#34;type&#34;] == &#34;inline&#34;:
                emote = discord.utils.get(
                    ctx.guild.emojis, name=document[&#39;name&#39;])
                try:
                    await emote.delete(reason=f&#34;Unloading emoji because it changed type.&#34;)
                except BaseException:
                    pass

            elif (size := len(requests.get(document[&#34;URL&#34;]).content)) &gt;= 262143:
                await ctx.send(f&#34;Emote `{document[&#39;name&#39;]}` is too big to become inline! ({round(size/1024)} kb vs 256 kb limit)&#34;)
                return

            else:
                await inject(ctx, document[&#39;name&#39;])  # inject the emote

            collection(&#34;emotes&#34;).update_one(
                {&#34;name&#34;: document[&#39;name&#39;], &#34;server&#34;: ctx.guild.id}, {&#34;$set&#34;: {&#34;type&#34;: newtype}})

            await ctx.send(f&#34;Emote `{document[&#39;name&#39;]}` is now of type `{newtype}`&#34;)

        elif emote := discord.utils.get(ctx.guild.emojis, name=name):
            # in server, and not on mongodb (fringe case)
            await upload(ctx, name, emote.url, &#34;big&#34;)
            try:
                await emote.delete(reason=f&#34;Unloading emoji because it changed type.&#34;)
            except BaseException:
                pass
            await ctx.send(f&#34;Emote `{name}` is now of type `big` (newly uploaded)&#34;)

        else:
            # not in mongodb or in server
            await ctx.send(f&#34;Emote `{name}` was not found.&#34;)

    @commands.Cog.listener()
    async def on_message(self, message: discord.message):
        &#39;&#39;&#39;
        Emote listener
        &#39;&#39;&#39;
        async def pullemote(em):
            return await inline(await self.bot.get_context(message),
                                em.strip(&#39;:&#39;).strip(&#34; &#34;))

        if message.content and not message.author.bot and message.guild:

            # scan for inline emotes
            if match := re.findall(
                    r&#34;(?&lt;!&lt;):\s*[0-9A-z]+\s*:(?!\d+&gt;)&#34;,
                    message.clean_content):
                s = message.content
                send = False
                for i in match:
                    if emote := await pullemote(i):
                        send = True
                        s = s.replace(i, str(emote))
                    # else:
                    # Handled by Go Module

                if send:
                    await echo(await self.bot.get_context(message),
                               member=message.author, content=s,
                               file=await message.attachments[0].to_file()
                               if message.attachments else None,
                               embed=message.embeds[0]
                               if message.embeds else None)

                    await message.delete()

            # scan for changing emotes
            elif message.content[0] == &#39;/&#39; and message.content[-1] == &#39;/&#39; and \
                    len(message.content) &gt; 1:
                # Swap type of emote
                await self.swaptype(
                    await self.bot.get_context(
                        message), message.content.strip(&#39;/&#39;).strip(&#34; &#34;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>discord.ext.commands.cog.Cog</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="Comrade.components.servertools.Emotes.add"><code class="name">var <span class="ident">add</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.servertools.Emotes.big"><code class="name">var <span class="ident">big</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.servertools.Emotes.emote"><code class="name">var <span class="ident">emote</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.servertools.Emotes.gallery"><code class="name">var <span class="ident">gallery</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.servertools.Emotes.inline"><code class="name">var <span class="ident">inline</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.servertools.Emotes.list"><code class="name">var <span class="ident">list</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.servertools.Emotes.remove"><code class="name">var <span class="ident">remove</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.servertools.Emotes.rename"><code class="name">var <span class="ident">rename</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.servertools.Emotes.swaptype"><code class="name">var <span class="ident">swaptype</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Comrade.components.servertools.Emotes.on_message"><code class="name flex">
<span>async def <span class="ident">on_message</span></span>(<span>self, message:¬†<module¬†'discord.message'¬†from¬†'c:\\python38\\lib\\site-packages\\discord\\message.py'>)</span>
</code></dt>
<dd>
<div class="desc"><p>Emote listener</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@commands.Cog.listener()
async def on_message(self, message: discord.message):
    &#39;&#39;&#39;
    Emote listener
    &#39;&#39;&#39;
    async def pullemote(em):
        return await inline(await self.bot.get_context(message),
                            em.strip(&#39;:&#39;).strip(&#34; &#34;))

    if message.content and not message.author.bot and message.guild:

        # scan for inline emotes
        if match := re.findall(
                r&#34;(?&lt;!&lt;):\s*[0-9A-z]+\s*:(?!\d+&gt;)&#34;,
                message.clean_content):
            s = message.content
            send = False
            for i in match:
                if emote := await pullemote(i):
                    send = True
                    s = s.replace(i, str(emote))
                # else:
                # Handled by Go Module

            if send:
                await echo(await self.bot.get_context(message),
                           member=message.author, content=s,
                           file=await message.attachments[0].to_file()
                           if message.attachments else None,
                           embed=message.embeds[0]
                           if message.embeds else None)

                await message.delete()

        # scan for changing emotes
        elif message.content[0] == &#39;/&#39; and message.content[-1] == &#39;/&#39; and \
                len(message.content) &gt; 1:
            # Swap type of emote
            await self.swaptype(
                await self.bot.get_context(
                    message), message.content.strip(&#39;/&#39;).strip(&#34; &#34;))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Comrade.components.servertools.Moderation"><code class="flex name class">
<span>class <span class="ident">Moderation</span></span>
<span>(</span><span>bot)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class that all cogs must inherit from.</p>
<p>A cog is a collection of commands, listeners, and optional state to
help group commands together. More information on them can be found on
the :ref:<code>ext_commands_cogs</code> page.</p>
<p>When inheriting from this class, the options shown in :class:<code>CogMeta</code>
are equally valid here.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Moderation(commands.Cog):
    def __init__(self, bot):
        self.bot: commands.Bot = bot

    @commands.Cog.listener()
    async def on_typing(self, channel, user, when):
        &#39;&#39;&#39;
        Prepare moderation filters
        &#39;&#39;&#39;
        # If user is a threat, raise shield

    @commands.command()
    @commands.guild_only()
    async def mute(self, ctx: commands.Context, *, member: discord.Member):
        &#39;&#39;&#39;
        Votes to mute a selected user.
        As OP: Mute the user
        &#39;&#39;&#39;
        OP = isOP()(ctx)

        mutedrole = await role(ctx.guild, &#34;Comrade-Mute&#34;)

        user_info = collection(&#34;users&#34;).find_one(ufil(member))
        vm = user_info[&#34;moderation&#34;][&#34;mute-votes&#34;]

        mutereq = collection(
            &#34;servers&#34;).find_one(ctx.guild.id)[&#34;thresholds&#34;][&#34;mute&#34;]

        &#39;&#39;&#39;
        Dynamic mute requirement support
        &#39;&#39;&#39;
        if type(mutereq) == str and &#34;%&#34; in mutereq:
            mutereq = dynamic_threshold(
                ctx.guild, float(mutereq.strip(&#34;%&#34;).strip()))
            await ctx.send(
                f&#34;Dynamic mute threshold equals to {mutereq} online members needed to mute.&#34;)

        decision = &#34;unmute&#34; if mutedrole in member.roles else &#34;mute&#34;

        if ctx.author.id not in vm or OP:

            if not OP:
                collection(&#34;users&#34;).update_one(
                    ufil(member),
                    {&#34;$push&#34;: {&#34;moderation.mute-votes&#34;: ctx.author.id}})

                await ctx.send(
                    f&#34;Vote to {decision} {member.display_name} added. ({len(vm) + 1}/{mutereq} votes)&#34;)

            if len(vm) + 1 &gt;= mutereq or OP:
                if mutedrole in member.roles:
                    roles = member.roles
                    roles.remove(mutedrole)
                    await member.edit(roles=roles)
                    await ctx.send(f&#34;{member.display_name} was unmuted.&#34;)
                else:
                    roles = member.roles
                    roles.append(mutedrole)
                    await member.edit(roles=roles)
                    await ctx.send(f&#34;{member.display_name} was muted.&#34;)

                    # Update perms for muted role
                    for channel in ctx.guild.channels:
                        await channel.set_permissions(
                            mutedrole,
                            send_messages=False, add_reactions=False)

                collection(&#34;users&#34;).update_one(
                    ufil(member),
                    {&#34;$set&#34;: {&#34;moderation.mute-votes&#34;: []}})
        else:
            collection(&#34;users&#34;).update_one(
                    ufil(member),
                    {&#34;$pull&#34;: {&#34;moderation.mute-votes&#34;: ctx.author.id}})

            await ctx.send(
                    f&#34;Vote to {decision} {member.display_name} added. ({len(vm) - 1}/{mutereq} votes)&#34;)

    @commands.command()
    @commands.guild_only()
    async def kick(self, ctx: commands.Context, *, member: discord.Member):
        &#39;&#39;&#39;
        Votes to kick a user from the server.
        &#39;&#39;&#39;
        user_info = collection(&#34;users&#34;).find_one(ufil(member))
        vk = user_info[&#34;moderation&#34;][&#34;kick-votes&#34;]

        kickreq = collection(
            &#34;servers&#34;).find_one(ctx.guild.id)[&#34;thresholds&#34;][&#34;kick&#34;]

        &#39;&#39;&#39;
        Dynamic kick requirement
        &#39;&#39;&#39;
        if type(kickreq) == str and &#34;%&#34; in kickreq:
            kickreq = dynamic_threshold(
                ctx.guild, float(kickreq.strip(&#34;%&#34;).strip()))
            await ctx.send(
                f&#34;Dynamic mute threshold equals to {kickreq} online members needed to mute.&#34;)

        if ctx.author.id not in vk:
            collection(&#34;users&#34;).update_one(
                        ufil(member),
                        {&#34;$push&#34;: {&#34;moderation.kick-votes&#34;: ctx.author.id}})
            await ctx.send(f&#34;Vote to kick {member.display_name} added. ({len(vk) + 1}/{kickreq} votes)&#34;)

            if len(vk) + 1 &gt;= kickreq:

                collection(&#34;users&#34;).update_one(
                    ufil(member),
                    {&#34;$set&#34;: {&#34;moderation.kick-votes&#34;: []}})
                await ctx.guild.kick(member)
                await ctx.send(f&#34;{member.display_name} was kicked.&#34;)

        else:
            collection(&#34;users&#34;).update_one(
                        ufil(member),
                        {&#34;$pull&#34;: {&#34;moderation.kick-votes&#34;: ctx.author.id}})
            await ctx.send(f&#34;Vote to kick {member.display_name} removed. ({len(vk) - 1}/{kickreq} votes)&#34;)

    @commands.command()
    @commands.check(isOP())
    @commands.guild_only()
    async def banword(self, ctx: commands.Context,
                      member: typing.Optional[discord.Member] = None,
                      threshold: typing.Optional[int] = 100, *, word):
        &#39;&#39;&#39;
        Bans a word, with an optional person to ban the word for,
        and a percentage similarity threshold required to trigger.
        If no member is specified, the word is banned for the whole server
        If no threshold is specified, the default threshold is 100
        (exact match required)
        Use \\ to escape arguments
        &#39;&#39;&#39;
        word = word.lstrip(&#34;\\&#34;)  # strip \

        if member:
            user_cfg = collection(&#34;users&#34;).find_one(ufil(member))

            if word in user_cfg[&#34;moderation&#34;][&#34;banned-words&#34;]:
                collection(&#34;users&#34;).update_one(
                    ufil(member),
                    {&#34;$unset&#34;: {f&#34;moderation.banned-words.{word}&#34;: &#34;&#34;}})
                await ctx.send(
                    f&#34;Word has been removed from {member.display_name}&#39;s set of personal banned words.&#34;)

            else:
                collection(&#34;users&#34;).update_one(
                    ufil(member),
                    {&#34;$set&#34;: {f&#34;moderation.banned-words.{word}&#34;: threshold}})
                await ctx.send(
                    f&#34;Word has been added to {member.display_name}&#39;s set of personal banned words.\nActivation threshold: {threshold}%&#34;)

        else:
            server_cfg = collection(&#34;servers&#34;).find_one(ctx.guild.id)

            if word in server_cfg[&#34;global-banned-words&#34;]:
                collection(&#34;servers&#34;).update_one(
                    {&#34;_id&#34;: ctx.guild.id},
                    {&#34;$unset&#34;: {f&#34;global-banned-words.{word}&#34;: &#34;&#34;}})
                await ctx.send(
                    f&#34;Word has been removed from {ctx.guild.name}&#39;s global banned words.&#34;)

            else:
                collection(&#34;servers&#34;).update_one(
                    {&#34;_id&#34;: ctx.guild.id},
                    {&#34;$set&#34;: {f&#34;global-banned-words.{word}&#34;: threshold}})
                await ctx.send(
                    f&#34;Word has been added to {member.display_name}&#39;s set of personal banned words.\nActivation threshold: {threshold}%&#34;)

    @commands.command()
    @commands.check_any(commands.check(isOP()), isServerOwner())
    async def op(self, ctx, *, member: discord.Member):
        &#39;&#39;&#39;
        OPs a member
        &#39;&#39;&#39;
        collection(&#34;users&#34;).update_one(ufil(member), {&#34;$set&#34;: {&#34;OP&#34;: True}})
        op_list.cache_clear()
        await ctx.send(f&#34;{member.display_name} is now OP.&#34;)

    @commands.command()
    @commands.check(isOP())
    async def deop(self, ctx, *, member: discord.Member):
        &#39;&#39;&#39;
        de-OPs a member
        &#39;&#39;&#39;
        collection(&#34;users&#34;).update_one(ufil(member), {&#34;$set&#34;: {&#34;OP&#34;: False}})
        op_list.cache_clear()
        await ctx.send(f&#34;{member.display_name} is no longer OP.&#34;)

    @commands.command()
    @commands.check(isOP())
    async def threat(self, ctx, level: int, *, member: discord.Member):
        &#39;&#39;&#39;
        sets a member&#39;s threat level
        &#39;&#39;&#39;
        collection(
            &#34;users&#34;).update_one(
                ufil(member), {&#34;$set&#34;: {&#34;moderation.threat-level&#34;: level}})
        threat_list.cache_clear()
        await ctx.send(f&#34;{member.display_name} is now threat level `{level}`&#34;)

    @commands.Cog.listener()
    async def on_message(self, message: discord.message):
        if not message.author.bot and message.guild and \
               message.content == &#34;ZA HANDO&#34;:
            args = (message.content.lower()).split()
            amount = 20

            if len(args) &gt; 2 and args[2].isnumeric():
                amount = int(args[2])

            if amount &gt; 200 and not isOP()(await self.bot.get_context(message)):
                await message.channel.send(&#34;No&#34;)
            else:
                duration = collection(
                    &#34;servers&#34;).find_one(
                        message.guild.id)[&#34;durations&#34;][&#34;zahando&#34;]

                froom = &#34;from &#34; + str(message.mentions[0]) if message.mentions else &#34;&#34;

                m = await message.channel.send(
                    f&#34;React with &#39;‚úã&#39; to purge the channel of {amount} messages {froom}. You have **{duration} seconds** to vote.&#34;,
                    delete_after=duration)

                await m.add_reaction(&#34;‚úã&#34;)

                voted = [message.author.id]

                def check(reaction, user):

                    voted_already = user.id in voted
                    voted.append(user.id)

                    return reaction.emoji == &#34;‚úã&#34; and not user.bot and (
                            (reaction.message.id == m.id and not voted_already)
                            or cfg[&#34;Settings&#34;][&#34;development-mode&#34;] == &#34;True&#34;)

                await self.bot.wait_for(
                    &#34;reaction_add&#34;, check=check, timeout=duration)

                await zahando(message.channel, amount, message.mentions[0])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>discord.ext.commands.cog.Cog</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="Comrade.components.servertools.Moderation.banword"><code class="name">var <span class="ident">banword</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.servertools.Moderation.deop"><code class="name">var <span class="ident">deop</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.servertools.Moderation.kick"><code class="name">var <span class="ident">kick</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.servertools.Moderation.mute"><code class="name">var <span class="ident">mute</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.servertools.Moderation.op"><code class="name">var <span class="ident">op</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.servertools.Moderation.threat"><code class="name">var <span class="ident">threat</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Comrade.components.servertools.Moderation.on_message"><code class="name flex">
<span>async def <span class="ident">on_message</span></span>(<span>self, message:¬†<module¬†'discord.message'¬†from¬†'c:\\python38\\lib\\site-packages\\discord\\message.py'>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@commands.Cog.listener()
async def on_message(self, message: discord.message):
    if not message.author.bot and message.guild and \
           message.content == &#34;ZA HANDO&#34;:
        args = (message.content.lower()).split()
        amount = 20

        if len(args) &gt; 2 and args[2].isnumeric():
            amount = int(args[2])

        if amount &gt; 200 and not isOP()(await self.bot.get_context(message)):
            await message.channel.send(&#34;No&#34;)
        else:
            duration = collection(
                &#34;servers&#34;).find_one(
                    message.guild.id)[&#34;durations&#34;][&#34;zahando&#34;]

            froom = &#34;from &#34; + str(message.mentions[0]) if message.mentions else &#34;&#34;

            m = await message.channel.send(
                f&#34;React with &#39;‚úã&#39; to purge the channel of {amount} messages {froom}. You have **{duration} seconds** to vote.&#34;,
                delete_after=duration)

            await m.add_reaction(&#34;‚úã&#34;)

            voted = [message.author.id]

            def check(reaction, user):

                voted_already = user.id in voted
                voted.append(user.id)

                return reaction.emoji == &#34;‚úã&#34; and not user.bot and (
                        (reaction.message.id == m.id and not voted_already)
                        or cfg[&#34;Settings&#34;][&#34;development-mode&#34;] == &#34;True&#34;)

            await self.bot.wait_for(
                &#34;reaction_add&#34;, check=check, timeout=duration)

            await zahando(message.channel, amount, message.mentions[0])</code></pre>
</details>
</dd>
<dt id="Comrade.components.servertools.Moderation.on_typing"><code class="name flex">
<span>async def <span class="ident">on_typing</span></span>(<span>self, channel, user, when)</span>
</code></dt>
<dd>
<div class="desc"><p>Prepare moderation filters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@commands.Cog.listener()
async def on_typing(self, channel, user, when):
    &#39;&#39;&#39;
    Prepare moderation filters
    &#39;&#39;&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Comrade.components.servertools.Sniper"><code class="flex name class">
<span>class <span class="ident">Sniper</span></span>
<span>(</span><span>bot)</span>
</code></dt>
<dd>
<div class="desc"><p>Similar to Dank Memer Bot's snipe functionality</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sniper(commands.Cog):
    &#39;&#39;&#39;
    Similar to Dank Memer Bot&#39;s snipe functionality
    &#39;&#39;&#39;
    def __init__(self, bot):
        self.bot: commands.Bot = bot
        self.last_deleted = defaultdict(lambda: None)
        self.last_edited = defaultdict(lambda: None)

    @commands.Cog.listener()
    async def on_message_delete(self, message):
        self.last_deleted[message.channel.id] = message

    @commands.Cog.listener()
    async def on_message_edit(self, before, after):
        self.last_deleted[after.channel.id] = (before, after)

    @commands.command()
    async def deleted(self, ctx: commands.Context):
        &#39;&#39;&#39;
        Retrieves the last message deleted in the channel
        &#39;&#39;&#39;
        if msg := self.last_deleted[ctx.channel.id]:
            await echo(ctx, msg.author, msg.content,
                       msg.attachments[0] if msg.attachments else None,
                       msg.embeds[0] if msg.embeds else None)
            self.last_deleted[ctx.channel.id] = None
        else:
            await ctx.send(&#34;No known deleted messages&#34;)

    @commands.command()
    async def edited(self, ctx: commands.Context):
        &#39;&#39;&#39;
        Retrieves the last message edited in the channel
        &#39;&#39;&#39;
        if msg := self.last_edited[ctx.channel.id]:
            before, after = msg
            await echo(ctx, before.author, before.content,
                       before.attachments[0] if before.attachments else None,
                       before.embeds[0] if before.embeds else None)
            await ctx.send(after.jump_url)
            self.last_edited[ctx.channel.id] = None
        else:
            await ctx.send(&#34;No known edited messages&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>discord.ext.commands.cog.Cog</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="Comrade.components.servertools.Sniper.deleted"><code class="name">var <span class="ident">deleted</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.servertools.Sniper.edited"><code class="name">var <span class="ident">edited</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Comrade.components.servertools.Sniper.on_message_delete"><code class="name flex">
<span>async def <span class="ident">on_message_delete</span></span>(<span>self, message)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@commands.Cog.listener()
async def on_message_delete(self, message):
    self.last_deleted[message.channel.id] = message</code></pre>
</details>
</dd>
<dt id="Comrade.components.servertools.Sniper.on_message_edit"><code class="name flex">
<span>async def <span class="ident">on_message_edit</span></span>(<span>self, before, after)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@commands.Cog.listener()
async def on_message_edit(self, before, after):
    self.last_deleted[after.channel.id] = (before, after)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Comrade.components.servertools.TextFilter"><code class="flex name class">
<span>class <span class="ident">TextFilter</span></span>
<span>(</span><span>bot)</span>
</code></dt>
<dd>
<div class="desc"><p>Comrade moderation module</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TextFilter(commands.Cog):
    &#39;&#39;&#39;
    Comrade moderation module
    &#39;&#39;&#39;
    def __init__(self, bot):
        self.bot = bot

        self.bucket = defaultdict(lambda: defaultdict(list))
        # stores a bunch of messages

    @commands.Cog.listener()
    async def on_message(self, message: discord.message):
        if not message.author.bot and message.guild:
            # moderation system
            if text_filter(message.content, message.author, message.guild) or \
                    content_filter(message):
                await message.delete()

            else:
                message_chain: list = self.bucket[
                    message.guild.id][message.author.id]
                message_chain.append(message)

                joined = &#34; &#34;.join([m.content for m in message_chain])

                if text_filter(joined, message.author, message.guild):
                    for m in message_chain:
                        try:
                            await m.delete()
                        except Exception:
                            logger.exception(
                                f&#34;Cannot delete message {m.content}&#34;)
                    message_chain.clear()

                elif len(message_chain) &gt; int(
                        cfg[&#34;Performance&#34;][&#34;moderation-buffer-limit&#34;]):
                    message_chain.pop(0)

    @commands.Cog.listener()
    async def on_raw_message_edit(self, payload):
        &#39;&#39;&#39;
        Catch people trying to edit messages
        &#39;&#39;&#39;
        message = await self.bot.get_channel(
            payload.channel_id).fetch_message(
                payload.message_id) if not \
            payload.cached_message else payload.cached_message

        if message:
            await self.on_message(message)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>discord.ext.commands.cog.Cog</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Comrade.components.servertools.TextFilter.on_message"><code class="name flex">
<span>async def <span class="ident">on_message</span></span>(<span>self, message:¬†<module¬†'discord.message'¬†from¬†'c:\\python38\\lib\\site-packages\\discord\\message.py'>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@commands.Cog.listener()
async def on_message(self, message: discord.message):
    if not message.author.bot and message.guild:
        # moderation system
        if text_filter(message.content, message.author, message.guild) or \
                content_filter(message):
            await message.delete()

        else:
            message_chain: list = self.bucket[
                message.guild.id][message.author.id]
            message_chain.append(message)

            joined = &#34; &#34;.join([m.content for m in message_chain])

            if text_filter(joined, message.author, message.guild):
                for m in message_chain:
                    try:
                        await m.delete()
                    except Exception:
                        logger.exception(
                            f&#34;Cannot delete message {m.content}&#34;)
                message_chain.clear()

            elif len(message_chain) &gt; int(
                    cfg[&#34;Performance&#34;][&#34;moderation-buffer-limit&#34;]):
                message_chain.pop(0)</code></pre>
</details>
</dd>
<dt id="Comrade.components.servertools.TextFilter.on_raw_message_edit"><code class="name flex">
<span>async def <span class="ident">on_raw_message_edit</span></span>(<span>self, payload)</span>
</code></dt>
<dd>
<div class="desc"><p>Catch people trying to edit messages</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@commands.Cog.listener()
async def on_raw_message_edit(self, payload):
    &#39;&#39;&#39;
    Catch people trying to edit messages
    &#39;&#39;&#39;
    message = await self.bot.get_channel(
        payload.channel_id).fetch_message(
            payload.message_id) if not \
        payload.cached_message else payload.cached_message

    if message:
        await self.on_message(message)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Comrade.components.servertools.Users"><code class="flex name class">
<span>class <span class="ident">Users</span></span>
<span>(</span><span>bot)</span>
</code></dt>
<dd>
<div class="desc"><p>A set of commands for inspecting and working with
Discord users</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Users(commands.Cog):
    &#39;&#39;&#39;
    A set of commands for inspecting and working with
    Discord users
    &#39;&#39;&#39;

    def __init__(self, bot):
        self.bot: commands.Bot = bot

    @commands.command(aliases=[&#34;profile&#34;])
    async def userinfo(self, ctx: commands.Context, *,
                       member: typing.Union[discord.Member,
                                            discord.User] = None):
        &#39;&#39;&#39;
        Displays User Information of said person
        Developed by Slyflare
        &#39;&#39;&#39;
        if not member:
            member = ctx.author

        e = discord.Embed(colour=member.colour)
        e.set_author(name=f&#34;{member.display_name} ({member})&#34;,
                     icon_url=member.avatar_url)
        e.set_thumbnail(url=member.avatar_url)
        e.set_footer(text=f&#34;ID: {member.id}&#34;)

        e.add_field(name=&#34;Is Human&#34;,
                    value=not member.bot)

        e.add_field(name=&#34;Account Created&#34;,
                    value=member.created_at.strftime(
                        &#39;%B %d %Y at %I:%M:%S %p %Z&#39;), inline=False)

        if ctx.guild:
            user_information = collection(
                &#34;users&#34;).find_one(ufil(member))

            e.add_field(name=&#34;Joined Server&#34;,
                        value=member.joined_at.strftime(
                            &#39;%B %d %Y at %I:%M:%S %p %Z&#39;), inline=False)

            if w := user_information[&#34;daily-weight&#34;]:
                e.add_field(name=&#34;Daily Weight&#34;, value=w)

            if w := user_information[&#34;OP&#34;]:
                e.add_field(name=&#34;OP&#34;, value=w)

            if (w := user_information[&#34;moderation&#34;][&#34;threat-level&#34;]):
                e.add_field(name=&#34;Threat Level&#34;, value=w)

            if w := user_information[&#34;identity&#34;]:
                e.add_field(name=&#34;Identity&#34;, value=w)
            else:
                e.add_field(name=&#34;Identity&#34;, value=&#34;Unknown&#34;)

            e.add_field(name=&#34;Status&#34;,
                        value=member.status)

            e.add_field(name=&#34;On Mobile&#34;,
                        value=member.is_on_mobile())

            if w := user_information[&#34;last-online&#34;]:
                e.add_field(name=&#34;Last Online&#34;,
                            value=w)

            # Show stack of roles
            e.add_field(name=f&#34;Roles ({len(member.roles)})&#34;,
                        value=&#34;\n&#34;.join([
                            role.mention for role in member.roles]),
                        inline=False)

        await ctx.send(embed=e)

    @commands.command()
    @commands.guild_only()
    async def rolluser(self, ctx: commands.Context):
        &#39;&#39;&#39;
        Rolls a random user in the server, either weighted or unweighted
        &#39;&#39;&#39;
        mem = random_member_from_server(ctx.guild)
        await self.userinfo(ctx, member=mem)

    @commands.command()
    @commands.guild_only()
    async def track(self, ctx: commands.Context, *, member: discord.Member):
        &#39;&#39;&#39;
        Makes it so that when a user changes status, you are notified.
        This command is a toggle.
        &#39;&#39;&#39;
        notifiees = collection(
            &#34;users&#34;).find_one(ufil(member))[&#34;notify-status&#34;]

        if ctx.author.id in notifiees:
            collection(&#34;users&#34;).update_one(
                ufil(member),
                {&#34;$pull&#34;: {&#34;notify-status&#34;: ctx.author.id}})
            await ctx.send(
                f&#34;You will no longer be notified by when {member.display_name} changes their status.&#34;)
        else:
            collection(&#34;users&#34;).update_one(
                ufil(member),
                {&#34;$push&#34;: {&#34;notify-status&#34;: ctx.author.id}})
            await ctx.send(
                f&#34;You will now be notified by when {member.display_name} changes their status.&#34;)

    @commands.command()
    @commands.guild_only()
    async def identity(self, ctx: commands.Context,
                       member: typing.Optional[discord.Member] = None, *,
                       name: typing.Optional[str] = None):
        &#39;&#39;&#39;
        Looks up user with real identity, or sets their identity.
        &#39;&#39;&#39;
        if name and member:
            # Case: assign name to member
            collection(
                &#34;users&#34;).update_one(
                    ufil(member),
                    {&#34;$set&#34;: {&#34;identity&#34;: name}})
            await reactOK(ctx)
        elif name and (real_user := collection(
            &#34;users&#34;).find_one(
                {&#34;identity&#34;: re.compile(&#39;^&#39; + name + &#39;$&#39;, re.IGNORECASE)})):
            # Case: find unknown user
            user = ctx.guild.get_member(real_user[&#34;user&#34;])
            await self.userinfo(ctx, member=user)

        elif member:
            await ctx.send(collection(
                &#34;users&#34;).find_one(ufil(member))[&#34;identity&#34;])
        else:
            await ctx.send(&#34;No identity listed&#34;)

    @commands.command()
    @commands.guild_only()
    async def requiem(self, ctx: commands.Context,
                      day: int = 30, trim=False):
        &#39;&#39;&#39;
        Generates a list of users who have not talked in the past x days
        &#39;&#39;&#39;
        threshold = datetime.datetime.now() - datetime.timedelta(day)

        active_author_ids = set()

        for channel in ctx.guild.text_channels:

            active_ids_in_channel = await channel.history(
                limit=None, after=threshold).filter(
                    lambda msg: msg.type == discord.MessageType.default
            ).map(lambda msg: msg.author.id).flatten()

            active_author_ids += set(active_ids_in_channel)

        inactive_author_ids = set(
            [member.id for member in ctx.guild.members]) - active_author_ids

        await ctx.send(
            f&#34;{len(inactive_author_ids)} members detected to have not posted in the past {day} days.&#34;)

        OP = isOP()(ctx)  # check before trimming

        s = &#34;```&#34;
        for member in [
                await ctx.guild.get_member(
                    idd) for idd in inactive_author_ids]:
            s += member.display_name + &#34;\n&#34;

            if trim and OP:
                collection(&#34;users&#34;).update_one(
                    ufil(member), {&#34;$set&#34;: {&#34;daily-weight&#34;: 0}})
        s += &#34;```&#34;
        await ctx.send(s)

        if trim:
            await ctx.send(&#34;Users above have been removed from the daily member pool.&#34;)

    @commands.command()
    @commands.guild_only()
    async def modchance(self, ctx,
                        member: typing.Optional[discord.Member] = None):
        &#39;&#39;&#39;
        Shows the chance of a user to be member of the day [MoD]
        &#39;&#39;&#39;
        if not member:
            member = ctx.author

        _, weights = weight_table(ctx.guild)

        sum_of_weights = sum(weights)

        count = collection(
            &#34;users&#34;).find_one(ufil(member))[&#34;daily-weight&#34;]

        if sum_of_weights &gt; 0:
            await ctx.send(
                f&#34;{member.display_name}&#39;s chance of being rolled tomorrow is {count}/{sum_of_weights} ({round(count/sum_of_weights * 100, 2)}%)&#34;)
        else:
            await ctx.send(&#34;Daily weight cache is currently unavailable (may be being rebuilt).&#34;)

    @commands.command()
    @commands.guild_only()
    async def modweights(self, ctx):
        &#39;&#39;&#39;
        Shows relative weights of daily member table.
        &#39;&#39;&#39;
        member_ids, weights = weight_table(ctx.guild)

        pg = commands.Paginator()

        for i in range(len(weights)):
            pg.add_line(
                f&#34;{ctx.guild.get_member(member_ids[i]).display_name}: {weights[i]}&#34;)
        pg.add_line(f&#34;Total: {sum(weights)} entries.&#34;)

        for page in pg.pages:
            await ctx.send(page)

    @commands.Cog.listener()
    async def on_member_join(self, member: discord.Member):
        &#39;&#39;&#39;
        When a member joins the server.
        &#39;&#39;&#39;
        try:
            announcements_channel_id = collection(
                &#34;servers&#34;).find_one(
                    member.guild.id)[&#34;channels&#34;][&#34;announcements&#34;]
            channel = member.guild.get_channel(announcements_channel_id)
            await channel.send(f&#34;Welcome {member.display_name}!&#34;)
        except Exception:
            logger.exception(&#34;Member join&#34;)

        collection(&#34;users&#34;).insert_one(new_user(member))
        # New user entry in DB

    @commands.Cog.listener()
    async def on_member_remove(self, member: discord.Member):
        &#39;&#39;&#39;
        When a member leaves the server
        &#39;&#39;&#39;
        try:
            announcements_channel_id = collection(
                &#34;servers&#34;).find_one(member.guild.id)[&#34;channels&#34;][&#34;announcements&#34;]

            channel = member.guild.get_channel(announcements_channel_id)

            await channel.send(f&#34;:door: {member.display_name} has left.&#34;)
        except Exception:
            logger.exception(&#34;Member leave&#34;)

        collection(&#34;users&#34;).delete_one(ufil(member))
        # Delete DB entry

    @commands.Cog.listener()
    async def on_member_update(self,
                               before: discord.Member, after: discord.Member):
        &#39;&#39;&#39;
        Whenever a server member changes their state.
        &#39;&#39;&#39;
        if after.status != before.status:
            # status update

            if str(after.status) == &#34;offline&#34;:

                collection(&#34;users&#34;).update_one(
                    ufil(after),
                    {&#34;$set&#34;: {
                        &#34;last-online&#34;:
                        local_time().strftime(&#34;%I:%M:%S %p %Z&#34;)}})
            else:
                collection(&#34;users&#34;).update_one(
                    ufil(after),
                    {&#34;$set&#34;: {
                        &#34;last-online&#34;: &#34;Now&#34;}})

            for mem_id in collection(
                    &#34;users&#34;).find_one(
                        ufil(after))[&#34;notify-status&#34;]:
                mem = after.guild.get_member(mem_id)

                embed = discord.Embed(color=0xd7342a,
                    description=
                    f&#34;{str(before.status)} -&gt; {str(after.status)} @ {local_time().strftime(&#39;%I:%M:%S %p %Z&#39;)}&#34;)

                embed.set_author(
                    name=
                    f&#34;{after.display_name} ({str(after)}) is now {str(after.status)}.&#34;,
                    icon_url=after.avatar_url)
                embed.set_footer(
                    text=
                    f&#34;To unsubscribe, type [{bot_prefix}track {after.display_name}] in {after.guild.name}&#34;)

                await mem.send(embed=embed)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>discord.ext.commands.cog.Cog</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="Comrade.components.servertools.Users.identity"><code class="name">var <span class="ident">identity</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.servertools.Users.modchance"><code class="name">var <span class="ident">modchance</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.servertools.Users.modweights"><code class="name">var <span class="ident">modweights</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.servertools.Users.requiem"><code class="name">var <span class="ident">requiem</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.servertools.Users.rolluser"><code class="name">var <span class="ident">rolluser</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.servertools.Users.track"><code class="name">var <span class="ident">track</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.servertools.Users.userinfo"><code class="name">var <span class="ident">userinfo</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Comrade.components.servertools.Users.on_member_join"><code class="name flex">
<span>async def <span class="ident">on_member_join</span></span>(<span>self, member:¬†discord.member.Member)</span>
</code></dt>
<dd>
<div class="desc"><p>When a member joins the server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@commands.Cog.listener()
async def on_member_join(self, member: discord.Member):
    &#39;&#39;&#39;
    When a member joins the server.
    &#39;&#39;&#39;
    try:
        announcements_channel_id = collection(
            &#34;servers&#34;).find_one(
                member.guild.id)[&#34;channels&#34;][&#34;announcements&#34;]
        channel = member.guild.get_channel(announcements_channel_id)
        await channel.send(f&#34;Welcome {member.display_name}!&#34;)
    except Exception:
        logger.exception(&#34;Member join&#34;)

    collection(&#34;users&#34;).insert_one(new_user(member))</code></pre>
</details>
</dd>
<dt id="Comrade.components.servertools.Users.on_member_remove"><code class="name flex">
<span>async def <span class="ident">on_member_remove</span></span>(<span>self, member:¬†discord.member.Member)</span>
</code></dt>
<dd>
<div class="desc"><p>When a member leaves the server</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@commands.Cog.listener()
async def on_member_remove(self, member: discord.Member):
    &#39;&#39;&#39;
    When a member leaves the server
    &#39;&#39;&#39;
    try:
        announcements_channel_id = collection(
            &#34;servers&#34;).find_one(member.guild.id)[&#34;channels&#34;][&#34;announcements&#34;]

        channel = member.guild.get_channel(announcements_channel_id)

        await channel.send(f&#34;:door: {member.display_name} has left.&#34;)
    except Exception:
        logger.exception(&#34;Member leave&#34;)

    collection(&#34;users&#34;).delete_one(ufil(member))</code></pre>
</details>
</dd>
<dt id="Comrade.components.servertools.Users.on_member_update"><code class="name flex">
<span>async def <span class="ident">on_member_update</span></span>(<span>self, before:¬†discord.member.Member, after:¬†discord.member.Member)</span>
</code></dt>
<dd>
<div class="desc"><p>Whenever a server member changes their state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@commands.Cog.listener()
async def on_member_update(self,
                           before: discord.Member, after: discord.Member):
    &#39;&#39;&#39;
    Whenever a server member changes their state.
    &#39;&#39;&#39;
    if after.status != before.status:
        # status update

        if str(after.status) == &#34;offline&#34;:

            collection(&#34;users&#34;).update_one(
                ufil(after),
                {&#34;$set&#34;: {
                    &#34;last-online&#34;:
                    local_time().strftime(&#34;%I:%M:%S %p %Z&#34;)}})
        else:
            collection(&#34;users&#34;).update_one(
                ufil(after),
                {&#34;$set&#34;: {
                    &#34;last-online&#34;: &#34;Now&#34;}})

        for mem_id in collection(
                &#34;users&#34;).find_one(
                    ufil(after))[&#34;notify-status&#34;]:
            mem = after.guild.get_member(mem_id)

            embed = discord.Embed(color=0xd7342a,
                description=
                f&#34;{str(before.status)} -&gt; {str(after.status)} @ {local_time().strftime(&#39;%I:%M:%S %p %Z&#39;)}&#34;)

            embed.set_author(
                name=
                f&#34;{after.display_name} ({str(after)}) is now {str(after.status)}.&#34;,
                icon_url=after.avatar_url)
            embed.set_footer(
                text=
                f&#34;To unsubscribe, type [{bot_prefix}track {after.display_name}] in {after.guild.name}&#34;)

            await mem.send(embed=embed)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Comrade.components.servertools.Vault"><code class="flex name class">
<span>class <span class="ident">Vault</span></span>
<span>(</span><span>bot)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class that all cogs must inherit from.</p>
<p>A cog is a collection of commands, listeners, and optional state to
help group commands together. More information on them can be found on
the :ref:<code>ext_commands_cogs</code> page.</p>
<p>When inheriting from this class, the options shown in :class:<code>CogMeta</code>
are equally valid here.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Vault(commands.Cog):
    def __init__(self, bot):
        self.bot: commands.Bot = bot

    @commands.command()
    @commands.guild_only()
    async def randomvaultpost(self, ctx: commands.Context):
        &#39;&#39;&#39;
        Returns a random post from the vault.
        &#39;&#39;&#39;
        message = random.choice(vault_posts(ctx.guild.id))

        await echo(ctx, member=message.author, content=message.content,
                        file=message.attachments[0] if message.attachments else None,
                        embed=message.embeds[0] if message.embeds else None)

    @commands.command(aliases=[u&#34;\U0001F345&#34;])
    @commands.guild_only()
    async def vault(self, ctx: commands.Context, tgt=None):
        &#39;&#39;&#39;
        Vaults a post. Operates in 3 modes
        1. Vault a message sent by a user based on Message URL.
        ex. $c vault &lt;link to message&gt;
        2. Vault a message with an image attachment
        ex. $c vault and then upload an image with this message
        3. Vault a message with an image url
        ex. $c vault &lt;link to image&gt;
        &#39;&#39;&#39;
        IDmode = False

        if ctx.message.attachments:
            u = ctx.message.attachments[0].url
        elif tgt and tgt.isnumeric():
            u = await commands.MessageConverter().convert(ctx, tgt)
            IDmode = True
        else:
            try:
                u = await commands.MessageConverter().convert(ctx, tgt)
                IDmode = True
            except Exception:
                u = tgt  # URL directly

        duration = collection(&#34;servers&#34;).find_one(ctx.guild.id)[
            &#34;durations&#34;][&#34;vault&#34;]


        ee = discord.Embed(color=0xd7342a,
                        description= f&#34;React to this message with üçÖ to vault [this post]({ctx.message.jump_url if not IDmode else u.jump_url})&#34;
                        f&#34;\nYou have **{duration} seconds** to vote.&#34;)

        m = await ctx.send(embed=ee, delete_after=duration)

        await m.add_reaction(&#34;üçÖ&#34;)

        def check(reaction, user):
            return reaction.emoji == &#34;üçÖ&#34; and not user.bot and (
                (reaction.message.id == m.id and user != ctx.author)
                or cfg[&#34;Settings&#34;][&#34;development-mode&#34;] == &#34;True&#34;
                or isOP()(ctx))
        try:
            await self.bot.wait_for(&#34;reaction_add&#34;, check=check, timeout=duration)

            vault = ctx.guild.get_channel(
                collection(&#34;servers&#34;).find_one(ctx.guild.id)[&#34;channels&#34;][&#34;vault&#34;])

            if IDmode:
                e = discord.Embed(color=0xd7342a,
                    description=f&#34;[Source Message]({u.jump_url})&#34;)
                e.set_author(name=ctx.author.display_name, icon_url=ctx.author.avatar_url)
                e.set_footer(
                    text=f&#34;Originally sent in #{ctx.channel.name}, at {utc_to_local_time(u.created_at).strftime(&#39;%B %d %Y at %I:%M:%S %p %Z&#39;)}&#34;)
                await mimic(vault, content=u.content,
                username=u.author.display_name, avatar_url=u.author.avatar_url,
                file=await u.attachments[0].to_file() if u.attachments else None,
                embeds=u.embeds + [e] if u.embeds else [e])

            else:
                e = discord.Embed(color=0xd7342a,
                    description=f&#34;[Source Message]({ctx.message.jump_url})&#34;)
                e.set_author(name=ctx.author.display_name, icon_url=ctx.author.avatar_url)
                e.set_image(url=u)
                e.set_footer(
                    text=f&#34;Originally sent in #{ctx.channel.name}, at {utc_to_local_time(ctx.message.created_at).strftime(&#39;%B %d %Y at %I:%M:%S %p %Z&#39;)}&#34;)
                await vault.send(embed=e)

            await reactOK(ctx)
            # rebuild vault cache
            vault_posts.cache_clear()

            await m.edit(content=&#34;Vault operation successful.&#34;, embed=None)
        except asyncio.TimeoutError:
            await m.edit(&#34;Vault aborted (180s timeout).&#34;, embed=None)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>discord.ext.commands.cog.Cog</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="Comrade.components.servertools.Vault.randomvaultpost"><code class="name">var <span class="ident">randomvaultpost</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.servertools.Vault.vault"><code class="name">var <span class="ident">vault</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Comrade.components" href="../index.html">Comrade.components</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="Comrade.components.servertools.announcements" href="announcements.html">Comrade.components.servertools.announcements</a></code></li>
<li><code><a title="Comrade.components.servertools.database_tools" href="database_tools.html">Comrade.components.servertools.database_tools</a></code></li>
<li><code><a title="Comrade.components.servertools.emote_system" href="emote_system.html">Comrade.components.servertools.emote_system</a></code></li>
<li><code><a title="Comrade.components.servertools.message_copier" href="message_copier.html">Comrade.components.servertools.message_copier</a></code></li>
<li><code><a title="Comrade.components.servertools.message_sniper" href="message_sniper.html">Comrade.components.servertools.message_sniper</a></code></li>
<li><code><a title="Comrade.components.servertools.moderation" href="moderation.html">Comrade.components.servertools.moderation</a></code></li>
<li><code><a title="Comrade.components.servertools.server_activity" href="server_activity.html">Comrade.components.servertools.server_activity</a></code></li>
<li><code><a title="Comrade.components.servertools.text_filter" href="text_filter.html">Comrade.components.servertools.text_filter</a></code></li>
<li><code><a title="Comrade.components.servertools.user_tools" href="user_tools.html">Comrade.components.servertools.user_tools</a></code></li>
<li><code><a title="Comrade.components.servertools.vault" href="vault.html">Comrade.components.servertools.vault</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Comrade.components.servertools.Announcements" href="#Comrade.components.servertools.Announcements">Announcements</a></code></h4>
<ul class="">
<li><code><a title="Comrade.components.servertools.Announcements.addannounce" href="#Comrade.components.servertools.Announcements.addannounce">addannounce</a></code></li>
<li><code><a title="Comrade.components.servertools.Announcements.build_announcement_cache" href="#Comrade.components.servertools.Announcements.build_announcement_cache">build_announcement_cache</a></code></li>
<li><code><a title="Comrade.components.servertools.Announcements.cog_unload" href="#Comrade.components.servertools.Announcements.cog_unload">cog_unload</a></code></li>
<li><code><a title="Comrade.components.servertools.Announcements.dailyannounce" href="#Comrade.components.servertools.Announcements.dailyannounce">dailyannounce</a></code></li>
<li><code><a title="Comrade.components.servertools.Announcements.removeannounce" href="#Comrade.components.servertools.Announcements.removeannounce">removeannounce</a></code></li>
<li><code><a title="Comrade.components.servertools.Announcements.testannounce" href="#Comrade.components.servertools.Announcements.testannounce">testannounce</a></code></li>
<li><code><a title="Comrade.components.servertools.Announcements.timedannounce" href="#Comrade.components.servertools.Announcements.timedannounce">timedannounce</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Comrade.components.servertools.Copier" href="#Comrade.components.servertools.Copier">Copier</a></code></h4>
<ul class="">
<li><code><a title="Comrade.components.servertools.Copier.copymessages" href="#Comrade.components.servertools.Copier.copymessages">copymessages</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Comrade.components.servertools.Databases" href="#Comrade.components.servertools.Databases">Databases</a></code></h4>
<ul class="two-column">
<li><code><a title="Comrade.components.servertools.Databases.allusers" href="#Comrade.components.servertools.Databases.allusers">allusers</a></code></li>
<li><code><a title="Comrade.components.servertools.Databases.channelmappings" href="#Comrade.components.servertools.Databases.channelmappings">channelmappings</a></code></li>
<li><code><a title="Comrade.components.servertools.Databases.configure" href="#Comrade.components.servertools.Databases.configure">configure</a></code></li>
<li><code><a title="Comrade.components.servertools.Databases.on_guild_join" href="#Comrade.components.servertools.Databases.on_guild_join">on_guild_join</a></code></li>
<li><code><a title="Comrade.components.servertools.Databases.on_guild_remove" href="#Comrade.components.servertools.Databases.on_guild_remove">on_guild_remove</a></code></li>
<li><code><a title="Comrade.components.servertools.Databases.server" href="#Comrade.components.servertools.Databases.server">server</a></code></li>
<li><code><a title="Comrade.components.servertools.Databases.setchannel" href="#Comrade.components.servertools.Databases.setchannel">setchannel</a></code></li>
<li><code><a title="Comrade.components.servertools.Databases.user" href="#Comrade.components.servertools.Databases.user">user</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Comrade.components.servertools.Emotes" href="#Comrade.components.servertools.Emotes">Emotes</a></code></h4>
<ul class="two-column">
<li><code><a title="Comrade.components.servertools.Emotes.add" href="#Comrade.components.servertools.Emotes.add">add</a></code></li>
<li><code><a title="Comrade.components.servertools.Emotes.big" href="#Comrade.components.servertools.Emotes.big">big</a></code></li>
<li><code><a title="Comrade.components.servertools.Emotes.emote" href="#Comrade.components.servertools.Emotes.emote">emote</a></code></li>
<li><code><a title="Comrade.components.servertools.Emotes.gallery" href="#Comrade.components.servertools.Emotes.gallery">gallery</a></code></li>
<li><code><a title="Comrade.components.servertools.Emotes.inline" href="#Comrade.components.servertools.Emotes.inline">inline</a></code></li>
<li><code><a title="Comrade.components.servertools.Emotes.list" href="#Comrade.components.servertools.Emotes.list">list</a></code></li>
<li><code><a title="Comrade.components.servertools.Emotes.on_message" href="#Comrade.components.servertools.Emotes.on_message">on_message</a></code></li>
<li><code><a title="Comrade.components.servertools.Emotes.remove" href="#Comrade.components.servertools.Emotes.remove">remove</a></code></li>
<li><code><a title="Comrade.components.servertools.Emotes.rename" href="#Comrade.components.servertools.Emotes.rename">rename</a></code></li>
<li><code><a title="Comrade.components.servertools.Emotes.swaptype" href="#Comrade.components.servertools.Emotes.swaptype">swaptype</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Comrade.components.servertools.Moderation" href="#Comrade.components.servertools.Moderation">Moderation</a></code></h4>
<ul class="two-column">
<li><code><a title="Comrade.components.servertools.Moderation.banword" href="#Comrade.components.servertools.Moderation.banword">banword</a></code></li>
<li><code><a title="Comrade.components.servertools.Moderation.deop" href="#Comrade.components.servertools.Moderation.deop">deop</a></code></li>
<li><code><a title="Comrade.components.servertools.Moderation.kick" href="#Comrade.components.servertools.Moderation.kick">kick</a></code></li>
<li><code><a title="Comrade.components.servertools.Moderation.mute" href="#Comrade.components.servertools.Moderation.mute">mute</a></code></li>
<li><code><a title="Comrade.components.servertools.Moderation.on_message" href="#Comrade.components.servertools.Moderation.on_message">on_message</a></code></li>
<li><code><a title="Comrade.components.servertools.Moderation.on_typing" href="#Comrade.components.servertools.Moderation.on_typing">on_typing</a></code></li>
<li><code><a title="Comrade.components.servertools.Moderation.op" href="#Comrade.components.servertools.Moderation.op">op</a></code></li>
<li><code><a title="Comrade.components.servertools.Moderation.threat" href="#Comrade.components.servertools.Moderation.threat">threat</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Comrade.components.servertools.Sniper" href="#Comrade.components.servertools.Sniper">Sniper</a></code></h4>
<ul class="">
<li><code><a title="Comrade.components.servertools.Sniper.deleted" href="#Comrade.components.servertools.Sniper.deleted">deleted</a></code></li>
<li><code><a title="Comrade.components.servertools.Sniper.edited" href="#Comrade.components.servertools.Sniper.edited">edited</a></code></li>
<li><code><a title="Comrade.components.servertools.Sniper.on_message_delete" href="#Comrade.components.servertools.Sniper.on_message_delete">on_message_delete</a></code></li>
<li><code><a title="Comrade.components.servertools.Sniper.on_message_edit" href="#Comrade.components.servertools.Sniper.on_message_edit">on_message_edit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Comrade.components.servertools.TextFilter" href="#Comrade.components.servertools.TextFilter">TextFilter</a></code></h4>
<ul class="">
<li><code><a title="Comrade.components.servertools.TextFilter.on_message" href="#Comrade.components.servertools.TextFilter.on_message">on_message</a></code></li>
<li><code><a title="Comrade.components.servertools.TextFilter.on_raw_message_edit" href="#Comrade.components.servertools.TextFilter.on_raw_message_edit">on_raw_message_edit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Comrade.components.servertools.Users" href="#Comrade.components.servertools.Users">Users</a></code></h4>
<ul class="two-column">
<li><code><a title="Comrade.components.servertools.Users.identity" href="#Comrade.components.servertools.Users.identity">identity</a></code></li>
<li><code><a title="Comrade.components.servertools.Users.modchance" href="#Comrade.components.servertools.Users.modchance">modchance</a></code></li>
<li><code><a title="Comrade.components.servertools.Users.modweights" href="#Comrade.components.servertools.Users.modweights">modweights</a></code></li>
<li><code><a title="Comrade.components.servertools.Users.on_member_join" href="#Comrade.components.servertools.Users.on_member_join">on_member_join</a></code></li>
<li><code><a title="Comrade.components.servertools.Users.on_member_remove" href="#Comrade.components.servertools.Users.on_member_remove">on_member_remove</a></code></li>
<li><code><a title="Comrade.components.servertools.Users.on_member_update" href="#Comrade.components.servertools.Users.on_member_update">on_member_update</a></code></li>
<li><code><a title="Comrade.components.servertools.Users.requiem" href="#Comrade.components.servertools.Users.requiem">requiem</a></code></li>
<li><code><a title="Comrade.components.servertools.Users.rolluser" href="#Comrade.components.servertools.Users.rolluser">rolluser</a></code></li>
<li><code><a title="Comrade.components.servertools.Users.track" href="#Comrade.components.servertools.Users.track">track</a></code></li>
<li><code><a title="Comrade.components.servertools.Users.userinfo" href="#Comrade.components.servertools.Users.userinfo">userinfo</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Comrade.components.servertools.Vault" href="#Comrade.components.servertools.Vault">Vault</a></code></h4>
<ul class="">
<li><code><a title="Comrade.components.servertools.Vault.randomvaultpost" href="#Comrade.components.servertools.Vault.randomvaultpost">randomvaultpost</a></code></li>
<li><code><a title="Comrade.components.servertools.Vault.vault" href="#Comrade.components.servertools.Vault.vault">vault</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>