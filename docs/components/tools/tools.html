<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>Comrade.components.tools.tools API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Comrade.components.tools.tools</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import discord
from discord.ext import commands
import string
import re
import io
import typing
import asyncio
import matplotlib.pyplot as plt
import matplotlib as mpl
from sympy import pretty, sympify
from sympy.parsing.sympy_parser import (implicit_multiplication_application,
                                        factorial_notation, convert_xor,
                                        standard_transformations, parse_expr)

from bs4 import BeautifulSoup
from PyDictionary import PyDictionary
import urllib.request
from utils.utilities import webscrape_header, local_time
from utils.echo import echo
from utils.emoji_converter import textToEmoji
from db import collection

mpl.use(&#39;agg&#39;)  # Prevent tkinter backend from starting which kills webserver

transformations = standard_transformations + \
    (implicit_multiplication_application,) + (factorial_notation,) + (convert_xor,)

# Define constants for news function
with open(&#34;static/news_border.txt&#34;, &#34;r&#34;, encoding=&#34;utf-8&#34;) as f:
    BORDER_TOP, ACCENT_BORDER, BORDER_BOTTOM = f.read().splitlines()
    len_border = len(BORDER_TOP)


class Tools(commands.Cog):
    &#39;&#39;&#39;
    A set of miscellaneous tools for you to use.
    (News, Dictionary, Math, Poll, Channel Creation)
    &#39;&#39;&#39;
    # Can operate entiely outside of a server.

    def __init__(self, bot):
        self.bot: commands.Bot = bot
        mpl.rcParams[&#39;mathtext.fontset&#39;] = &#34;cm&#34;  # set to Computer Modern

    @commands.group(invoke_without_command=True)
    async def define(self, ctx: commands.Context, *, word):
        &#39;&#39;&#39;
        Defines a word
        &#39;&#39;&#39;
        if ctx.invoked_subcommand is None:
            await ctx.trigger_typing()

            dictionary = PyDictionary()

            if (meanings := dictionary.meaning(word)):

                printout = f&#34;**__{string.capwords(word)}__:**\n&#34;

                for wordtype in meanings:
                    defs = meanings[wordtype]
                    printout += f&#34;__{wordtype}__\n&#34;

                    for num, d in enumerate(defs, 1):
                        printout += f&#34;{num}. {d}\n&#34;

                await ctx.send(printout)

            else:
                await ctx.send(f&#34;Definition for `{word}` could not be found.&#34;)

    @define.command()
    async def urban(self, ctx: commands.Context, *, word):
        &#39;&#39;&#39;
        Defines a word in a dictionary

        Credits to MgWg
        &#39;&#39;&#39;
        printout = f&#34;**__{string.capwords(word)}__:**\n&#34;

        await ctx.trigger_typing()

        tags = &#39;%20&#39;.join(word.split(&#34; &#34;))
        url = &#39;https://www.urbandictionary.com/define.php?term=&#39; + tags

        request = urllib.request.Request(url, None, webscrape_header())

        try:
            response = urllib.request.urlopen(request)
        except Exception:
            await ctx.send(&#34;No results found.&#34;)
            return

        data = response.read()
        soup = BeautifulSoup(data, &#39;html.parser&#39;)
        # Regex pattern for finding text
        r = r&#39;(?&lt;=&lt;div class\=&#34;meaning&#34;&gt;)(.*?)(?=&lt;div class\=&#34;def-footer&#34;&gt;)&#39;
        num_results = re.findall(r, str(soup))

        def_1 = BeautifulSoup(num_results[0], features=&#34;html.parser&#34;)
        ex = def_1.find_all(&#39;div&#39;, {&#39;class&#39;: &#39;example&#39;})
        example = BeautifulSoup(str(ex[0]), features=&#34;html.parser&#34;).get_text()
        index = def_1.get_text().index(example)
        def_1 = def_1.get_text()[:index]

        printout += def_1 + f&#34;\n\n__Example:__\n*{example}*&#34;
        await ctx.send(printout)

    @commands.command()
    async def graph(self, ctx: commands.Context, *, function: str):
        &#39;&#39;&#39;
        Graphs a 1 variable algebraic function in some domain.
        Runs on SymPy. Syntax Reference: http://daabzlatex.s3.amazonaws.com/9065616cce623384fe5394eddfea4c52.pdf
        Example: x^2 + 6*x + 9, (x, -10, 10)
        &#39;&#39;&#39;
        await ctx.trigger_typing()
        try:
            # implicit multiplication
            function = re.sub(r&#34;([0-9])([a-z])&#34;, r&#34;\1*\2&#34;, function)
            function = function.replace(&#34;^&#34;, &#34;**&#34;)  # exponentiation
            graph = sympify(
                f&#34;plot({function}, title=&#39;Plot Requested by {ctx.author.display_name}&#39;, show=False)&#34;)

            backend = graph.backend(graph)
            backend.process_series()
            f = io.BytesIO()
            backend.fig.savefig(f, format=&#34;png&#34;, dpi=300)
            f.seek(0)
            backend.fig.clf()

            await ctx.send(file=discord.File(f, &#34;graph.png&#34;))
        except Exception as ex:
            await ctx.send(f&#34;Error: {ex}&#34;)

    @commands.command()
    async def calculate(self, ctx: commands.Context, *, expression: str):
        &#39;&#39;&#39;
        Evaluates a mathematical expression and returns the most simplified result.
        Runs on SymPy. Syntax Reference: http://daabzlatex.s3.amazonaws.com/9065616cce623384fe5394eddfea4c52.pdf
        &#39;&#39;&#39;
        try:
            exp = parse_expr(expression, transformations=transformations)

            try:
                approx = exp.evalf()
                await ctx.send(f&#34;```{pretty(exp, use_unicode = False)}```= `{approx}`&#34;)

            except Exception as ex:
                await ctx.send(f&#34;```{pretty(exp, use_unicode = False)}```&#34;)

        except Exception as ex:
            await ctx.send(f&#34;Error: {ex}&#34;)

    @commands.command()
    async def tex(self, ctx: commands.Context, *, text):
        &#39;&#39;&#39;
        Renders a LaTeX equation.
        &#39;&#39;&#39;
        await ctx.trigger_typing()

        L = len(text) if len(text) &gt;= 4 else 4
        S = int(630 / L) - 12  # approx text fit based on expression
        if S &lt; 20:
            S = 20

        # add text
        plt.text(0.5, 0.5, r&#34;$%s$&#34; %
                 text, fontsize=S, ha=&#39;center&#39;, va=&#39;center&#39;)

        # hide axes
        fig = plt.gca()
        plt.axis(&#39;off&#39;)
        fig.axes.get_xaxis().set_visible(False)
        fig.axes.get_yaxis().set_visible(False)

        f = io.BytesIO()
        plt.savefig(f, format=&#34;png&#34;)
        f.seek(0)
        plt.clf()

        await ctx.send(file=discord.File(f, &#34;renderedtex.png&#34;))

    @commands.Cog.listener()
    async def on_message(self, message: discord.Message):
        &#39;&#39;&#39;
        Inline calculator
        &#39;&#39;&#39;
        if message.content and \
                not message.author.bot and message.content[:2] == &#34;==&#34;:
            await self.calculate(
                await self.bot.get_context(message),
                expression=message.content[2:])

    @commands.command()
    async def news(self, ctx: commands.Context, *, content):
        &#39;&#39;&#39;
        Wraps a piece of text in a fancy border for news
        &#39;&#39;&#39;
        words = content.split(&#34; &#34;)
        lines = []
        buffer = &#34;&#34;  # line buffer

        while words:
            # do until the array of words is empty
            if len(words[0]) &gt;= len_border and (max_word := words.pop(0)):
                words = [max_word[:len_border - 2] + &#39;-&#39;,
                         max_word[len_border - 2:]] + words
                # case: word is too long

            while words and len(buffer + words[0]) &lt; len_border:
                buffer += words.pop(0) + &#34; &#34;

            lines.append(buffer.strip(&#34; &#34;).center(len_border))
            # center the text in the block after removing spaces
            buffer = &#34;&#34;

        content = &#34;\n&#34;.join(lines)

        if ctx.guild:
            # using monospaced font to fix spacing
            await echo(ctx, member=ctx.author,
                       content=f&#34;**```{BORDER_TOP}\n{ACCENT_BORDER}\n{content}\n{ACCENT_BORDER}\n{BORDER_BOTTOM}```**&#34;,
                       delete_msg=True)
        else:
            await ctx.send(f&#34;**```{BORDER_TOP}\n{ACCENT_BORDER}\n{content}\n{ACCENT_BORDER}\n{BORDER_BOTTOM}```**&#34;)

    @commands.command()
    @commands.guild_only()
    async def poll(self, ctx: commands.Context,
                   prompt: str, timeout: typing.Optional[int] = 60, *options):
        &#39;&#39;&#39;
        Creates a poll, with an optional timeout.
        Specify a prompt, and then split options by spaces.

        ex. `$c poll &#34;apples or bananas?&#34; &#34;apples are better&#34; &#34;bananas are the best!&#34;`

        Polls automatically time out after 60 minutes by default.
        &#39;&#39;&#39;

        if len(options) &lt; 36:

            lines = &#34;\n&#34;.join(
                [f&#34;{i+1}) {options[i]}&#34; for i in range(len(options))])

            e = discord.Embed(
                title=f&#34;**__POLL__:\n{prompt}**&#34;)

            for i in range(len(options)):
                e.add_field(color=0xd7342a,
                    name=f&#34;{i+1}) {options[i]}: 0&#34;,
                    value=&#34;No one&#34;,
                    inline=False)
            e.set_author(
                name=f&#34;{ctx.author.display_name}, react to this post with 🛑 to stop the poll.&#34;,
                icon_url=ctx.author.avatar_url)
            e.set_footer(
                text=f&#34;Updated {local_time().strftime(&#39;%I:%M:%S %p %Z&#39;)}&#34;)

            msg = await ctx.send(embed=e)

            reacts = &#34;123456789abcdefghijklmnopqrstuvwxyz&#34;

            cont = True

            # Apply reactions
            for i in range(len(options)):
                await msg.add_reaction(textToEmoji(reacts[i]))
            await msg.add_reaction(&#34;🛑&#34;)

            def check(reaction, user):
                return reaction.message.id == msg.id and not user.bot

            while cont:
                # Await Responses
                try:
                    pending_tasks = [
                        self.bot.wait_for(
                            &#39;reaction_add&#39;,
                            check=check,
                            timeout=60 * timeout),
                        self.bot.wait_for(
                            &#39;reaction_remove&#39;,
                            check=check,
                            timeout=60 * timeout)]
                    done_tasks, pending_tasks = await asyncio.wait(pending_tasks, return_when=asyncio.FIRST_COMPLETED)

                    for task in pending_tasks:
                        task.cancel()

                    for task in done_tasks:
                        reaction, user = await task

                    if reaction.emoji == &#34;🛑&#34; and user == ctx.author:
                        raise asyncio.TimeoutError

                    e = discord.Embed(color=0xd7342a,
                        title=f&#34;**__POLL__:\n{prompt}**&#34;)

                    for i in range(len(options)):

                        reaction = reaction.message.reactions[i]

                        users = [u.mention for u in await reaction.users().flatten() if u != self.bot.user]

                        people = &#34; &#34;.join(users)

                        e.add_field(
                            name=f&#34;{i+1}) {options[i]}: {len(users)}&#34;,
                            value=people if people else &#34;No one&#34;,
                            inline=False)
                    e.set_author(
                        name=f&#34;{ctx.author.display_name}, react to this post with 🛑 to stop the poll.&#34;,
                        icon_url=ctx.author.avatar_url)
                    e.set_footer(
                        text=f&#34;Updated {local_time().strftime(&#39;%I:%M:%S %p %Z&#39;)}&#34;)

                    await msg.edit(embed=e)

                except asyncio.TimeoutError:
                    cont = False

                    e = discord.Embed(color=0xd7342a,
                        title=f&#34;**__POLL (Closed)__:\n{prompt}**&#34;)

                    for i in range(len(options)):

                        reaction = (await ctx.channel.fetch_message(msg.id)).reactions[i]

                        users = [u.mention for u in await reaction.users().flatten() if u != self.bot.user]

                        people = &#34; &#34;.join(users)

                        e.add_field(
                            name=f&#34;{i+1}) {options[i]}: {len(users)}&#34;,
                            value=people if people else &#34;No one&#34;,
                            inline=False)

                    e.set_author(name=f&#34;Poll by {ctx.author.display_name}&#34;,
                                 icon_url=ctx.author.avatar_url)
                    e.set_footer(
                        text=f&#34;Closed {local_time().strftime(&#39;%I:%M:%S %p %Z&#39;)}&#34;)

                    await msg.delete()
                    await ctx.send(embed=e)

        else:
            await ctx.send(&#34;Sorry, you can only choose up to 35 options at a time.&#34;)

    @commands.command()
    @commands.guild_only()
    async def createChannel(self, ctx: commands.Context, *, channelname: str):
        &#39;&#39;&#39;
        Creates a channel, and gives the user who
        created it full permissions over it.

        If &#34;custom-channel-group&#34; is set in the
        server cfg, it will create the channel there,
        otherwise it will be the same category as where
        the command was called.
        &#39;&#39;&#39;
        await ctx.trigger_typing()

        server_cfg: dict = collection(&#34;servers&#34;).find_one(ctx.guild.id)

        try:
            custom_group = server_cfg[&#34;channels&#34;][&#34;custom&#34;]
        except Exception:
            if ctx.channel.category:
                custom_group = ctx.channel.category.id
            else:
                custom_group = 0

        if custom_group:
            # put in specific category
            group = ctx.guild.get_channel(custom_group)
            chn = await group.create_text_channel(channelname)
        else:
            # put in outside
            chn = await ctx.guild.create_text_channel(channelname)

        await chn.set_permissions(
            ctx.author, manage_channels=True, manage_roles=True)
        await ctx.send(f&#34;Channel has been created at {chn.mention}&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Comrade.components.tools.tools.Tools"><code class="flex name class">
<span>class <span class="ident">Tools</span></span>
<span>(</span><span>bot)</span>
</code></dt>
<dd>
<div class="desc"><p>A set of miscellaneous tools for you to use.
(News, Dictionary, Math, Poll, Channel Creation)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tools(commands.Cog):
    &#39;&#39;&#39;
    A set of miscellaneous tools for you to use.
    (News, Dictionary, Math, Poll, Channel Creation)
    &#39;&#39;&#39;
    # Can operate entiely outside of a server.

    def __init__(self, bot):
        self.bot: commands.Bot = bot
        mpl.rcParams[&#39;mathtext.fontset&#39;] = &#34;cm&#34;  # set to Computer Modern

    @commands.group(invoke_without_command=True)
    async def define(self, ctx: commands.Context, *, word):
        &#39;&#39;&#39;
        Defines a word
        &#39;&#39;&#39;
        if ctx.invoked_subcommand is None:
            await ctx.trigger_typing()

            dictionary = PyDictionary()

            if (meanings := dictionary.meaning(word)):

                printout = f&#34;**__{string.capwords(word)}__:**\n&#34;

                for wordtype in meanings:
                    defs = meanings[wordtype]
                    printout += f&#34;__{wordtype}__\n&#34;

                    for num, d in enumerate(defs, 1):
                        printout += f&#34;{num}. {d}\n&#34;

                await ctx.send(printout)

            else:
                await ctx.send(f&#34;Definition for `{word}` could not be found.&#34;)

    @define.command()
    async def urban(self, ctx: commands.Context, *, word):
        &#39;&#39;&#39;
        Defines a word in a dictionary

        Credits to MgWg
        &#39;&#39;&#39;
        printout = f&#34;**__{string.capwords(word)}__:**\n&#34;

        await ctx.trigger_typing()

        tags = &#39;%20&#39;.join(word.split(&#34; &#34;))
        url = &#39;https://www.urbandictionary.com/define.php?term=&#39; + tags

        request = urllib.request.Request(url, None, webscrape_header())

        try:
            response = urllib.request.urlopen(request)
        except Exception:
            await ctx.send(&#34;No results found.&#34;)
            return

        data = response.read()
        soup = BeautifulSoup(data, &#39;html.parser&#39;)
        # Regex pattern for finding text
        r = r&#39;(?&lt;=&lt;div class\=&#34;meaning&#34;&gt;)(.*?)(?=&lt;div class\=&#34;def-footer&#34;&gt;)&#39;
        num_results = re.findall(r, str(soup))

        def_1 = BeautifulSoup(num_results[0], features=&#34;html.parser&#34;)
        ex = def_1.find_all(&#39;div&#39;, {&#39;class&#39;: &#39;example&#39;})
        example = BeautifulSoup(str(ex[0]), features=&#34;html.parser&#34;).get_text()
        index = def_1.get_text().index(example)
        def_1 = def_1.get_text()[:index]

        printout += def_1 + f&#34;\n\n__Example:__\n*{example}*&#34;
        await ctx.send(printout)

    @commands.command()
    async def graph(self, ctx: commands.Context, *, function: str):
        &#39;&#39;&#39;
        Graphs a 1 variable algebraic function in some domain.
        Runs on SymPy. Syntax Reference: http://daabzlatex.s3.amazonaws.com/9065616cce623384fe5394eddfea4c52.pdf
        Example: x^2 + 6*x + 9, (x, -10, 10)
        &#39;&#39;&#39;
        await ctx.trigger_typing()
        try:
            # implicit multiplication
            function = re.sub(r&#34;([0-9])([a-z])&#34;, r&#34;\1*\2&#34;, function)
            function = function.replace(&#34;^&#34;, &#34;**&#34;)  # exponentiation
            graph = sympify(
                f&#34;plot({function}, title=&#39;Plot Requested by {ctx.author.display_name}&#39;, show=False)&#34;)

            backend = graph.backend(graph)
            backend.process_series()
            f = io.BytesIO()
            backend.fig.savefig(f, format=&#34;png&#34;, dpi=300)
            f.seek(0)
            backend.fig.clf()

            await ctx.send(file=discord.File(f, &#34;graph.png&#34;))
        except Exception as ex:
            await ctx.send(f&#34;Error: {ex}&#34;)

    @commands.command()
    async def calculate(self, ctx: commands.Context, *, expression: str):
        &#39;&#39;&#39;
        Evaluates a mathematical expression and returns the most simplified result.
        Runs on SymPy. Syntax Reference: http://daabzlatex.s3.amazonaws.com/9065616cce623384fe5394eddfea4c52.pdf
        &#39;&#39;&#39;
        try:
            exp = parse_expr(expression, transformations=transformations)

            try:
                approx = exp.evalf()
                await ctx.send(f&#34;```{pretty(exp, use_unicode = False)}```= `{approx}`&#34;)

            except Exception as ex:
                await ctx.send(f&#34;```{pretty(exp, use_unicode = False)}```&#34;)

        except Exception as ex:
            await ctx.send(f&#34;Error: {ex}&#34;)

    @commands.command()
    async def tex(self, ctx: commands.Context, *, text):
        &#39;&#39;&#39;
        Renders a LaTeX equation.
        &#39;&#39;&#39;
        await ctx.trigger_typing()

        L = len(text) if len(text) &gt;= 4 else 4
        S = int(630 / L) - 12  # approx text fit based on expression
        if S &lt; 20:
            S = 20

        # add text
        plt.text(0.5, 0.5, r&#34;$%s$&#34; %
                 text, fontsize=S, ha=&#39;center&#39;, va=&#39;center&#39;)

        # hide axes
        fig = plt.gca()
        plt.axis(&#39;off&#39;)
        fig.axes.get_xaxis().set_visible(False)
        fig.axes.get_yaxis().set_visible(False)

        f = io.BytesIO()
        plt.savefig(f, format=&#34;png&#34;)
        f.seek(0)
        plt.clf()

        await ctx.send(file=discord.File(f, &#34;renderedtex.png&#34;))

    @commands.Cog.listener()
    async def on_message(self, message: discord.Message):
        &#39;&#39;&#39;
        Inline calculator
        &#39;&#39;&#39;
        if message.content and \
                not message.author.bot and message.content[:2] == &#34;==&#34;:
            await self.calculate(
                await self.bot.get_context(message),
                expression=message.content[2:])

    @commands.command()
    async def news(self, ctx: commands.Context, *, content):
        &#39;&#39;&#39;
        Wraps a piece of text in a fancy border for news
        &#39;&#39;&#39;
        words = content.split(&#34; &#34;)
        lines = []
        buffer = &#34;&#34;  # line buffer

        while words:
            # do until the array of words is empty
            if len(words[0]) &gt;= len_border and (max_word := words.pop(0)):
                words = [max_word[:len_border - 2] + &#39;-&#39;,
                         max_word[len_border - 2:]] + words
                # case: word is too long

            while words and len(buffer + words[0]) &lt; len_border:
                buffer += words.pop(0) + &#34; &#34;

            lines.append(buffer.strip(&#34; &#34;).center(len_border))
            # center the text in the block after removing spaces
            buffer = &#34;&#34;

        content = &#34;\n&#34;.join(lines)

        if ctx.guild:
            # using monospaced font to fix spacing
            await echo(ctx, member=ctx.author,
                       content=f&#34;**```{BORDER_TOP}\n{ACCENT_BORDER}\n{content}\n{ACCENT_BORDER}\n{BORDER_BOTTOM}```**&#34;,
                       delete_msg=True)
        else:
            await ctx.send(f&#34;**```{BORDER_TOP}\n{ACCENT_BORDER}\n{content}\n{ACCENT_BORDER}\n{BORDER_BOTTOM}```**&#34;)

    @commands.command()
    @commands.guild_only()
    async def poll(self, ctx: commands.Context,
                   prompt: str, timeout: typing.Optional[int] = 60, *options):
        &#39;&#39;&#39;
        Creates a poll, with an optional timeout.
        Specify a prompt, and then split options by spaces.

        ex. `$c poll &#34;apples or bananas?&#34; &#34;apples are better&#34; &#34;bananas are the best!&#34;`

        Polls automatically time out after 60 minutes by default.
        &#39;&#39;&#39;

        if len(options) &lt; 36:

            lines = &#34;\n&#34;.join(
                [f&#34;{i+1}) {options[i]}&#34; for i in range(len(options))])

            e = discord.Embed(
                title=f&#34;**__POLL__:\n{prompt}**&#34;)

            for i in range(len(options)):
                e.add_field(color=0xd7342a,
                    name=f&#34;{i+1}) {options[i]}: 0&#34;,
                    value=&#34;No one&#34;,
                    inline=False)
            e.set_author(
                name=f&#34;{ctx.author.display_name}, react to this post with 🛑 to stop the poll.&#34;,
                icon_url=ctx.author.avatar_url)
            e.set_footer(
                text=f&#34;Updated {local_time().strftime(&#39;%I:%M:%S %p %Z&#39;)}&#34;)

            msg = await ctx.send(embed=e)

            reacts = &#34;123456789abcdefghijklmnopqrstuvwxyz&#34;

            cont = True

            # Apply reactions
            for i in range(len(options)):
                await msg.add_reaction(textToEmoji(reacts[i]))
            await msg.add_reaction(&#34;🛑&#34;)

            def check(reaction, user):
                return reaction.message.id == msg.id and not user.bot

            while cont:
                # Await Responses
                try:
                    pending_tasks = [
                        self.bot.wait_for(
                            &#39;reaction_add&#39;,
                            check=check,
                            timeout=60 * timeout),
                        self.bot.wait_for(
                            &#39;reaction_remove&#39;,
                            check=check,
                            timeout=60 * timeout)]
                    done_tasks, pending_tasks = await asyncio.wait(pending_tasks, return_when=asyncio.FIRST_COMPLETED)

                    for task in pending_tasks:
                        task.cancel()

                    for task in done_tasks:
                        reaction, user = await task

                    if reaction.emoji == &#34;🛑&#34; and user == ctx.author:
                        raise asyncio.TimeoutError

                    e = discord.Embed(color=0xd7342a,
                        title=f&#34;**__POLL__:\n{prompt}**&#34;)

                    for i in range(len(options)):

                        reaction = reaction.message.reactions[i]

                        users = [u.mention for u in await reaction.users().flatten() if u != self.bot.user]

                        people = &#34; &#34;.join(users)

                        e.add_field(
                            name=f&#34;{i+1}) {options[i]}: {len(users)}&#34;,
                            value=people if people else &#34;No one&#34;,
                            inline=False)
                    e.set_author(
                        name=f&#34;{ctx.author.display_name}, react to this post with 🛑 to stop the poll.&#34;,
                        icon_url=ctx.author.avatar_url)
                    e.set_footer(
                        text=f&#34;Updated {local_time().strftime(&#39;%I:%M:%S %p %Z&#39;)}&#34;)

                    await msg.edit(embed=e)

                except asyncio.TimeoutError:
                    cont = False

                    e = discord.Embed(color=0xd7342a,
                        title=f&#34;**__POLL (Closed)__:\n{prompt}**&#34;)

                    for i in range(len(options)):

                        reaction = (await ctx.channel.fetch_message(msg.id)).reactions[i]

                        users = [u.mention for u in await reaction.users().flatten() if u != self.bot.user]

                        people = &#34; &#34;.join(users)

                        e.add_field(
                            name=f&#34;{i+1}) {options[i]}: {len(users)}&#34;,
                            value=people if people else &#34;No one&#34;,
                            inline=False)

                    e.set_author(name=f&#34;Poll by {ctx.author.display_name}&#34;,
                                 icon_url=ctx.author.avatar_url)
                    e.set_footer(
                        text=f&#34;Closed {local_time().strftime(&#39;%I:%M:%S %p %Z&#39;)}&#34;)

                    await msg.delete()
                    await ctx.send(embed=e)

        else:
            await ctx.send(&#34;Sorry, you can only choose up to 35 options at a time.&#34;)

    @commands.command()
    @commands.guild_only()
    async def createChannel(self, ctx: commands.Context, *, channelname: str):
        &#39;&#39;&#39;
        Creates a channel, and gives the user who
        created it full permissions over it.

        If &#34;custom-channel-group&#34; is set in the
        server cfg, it will create the channel there,
        otherwise it will be the same category as where
        the command was called.
        &#39;&#39;&#39;
        await ctx.trigger_typing()

        server_cfg: dict = collection(&#34;servers&#34;).find_one(ctx.guild.id)

        try:
            custom_group = server_cfg[&#34;channels&#34;][&#34;custom&#34;]
        except Exception:
            if ctx.channel.category:
                custom_group = ctx.channel.category.id
            else:
                custom_group = 0

        if custom_group:
            # put in specific category
            group = ctx.guild.get_channel(custom_group)
            chn = await group.create_text_channel(channelname)
        else:
            # put in outside
            chn = await ctx.guild.create_text_channel(channelname)

        await chn.set_permissions(
            ctx.author, manage_channels=True, manage_roles=True)
        await ctx.send(f&#34;Channel has been created at {chn.mention}&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>discord.ext.commands.cog.Cog</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="Comrade.components.tools.tools.Tools.calculate"><code class="name">var <span class="ident">calculate</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.tools.tools.Tools.createChannel"><code class="name">var <span class="ident">createChannel</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.tools.tools.Tools.define"><code class="name">var <span class="ident">define</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.tools.tools.Tools.graph"><code class="name">var <span class="ident">graph</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.tools.tools.Tools.news"><code class="name">var <span class="ident">news</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.tools.tools.Tools.poll"><code class="name">var <span class="ident">poll</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.tools.tools.Tools.tex"><code class="name">var <span class="ident">tex</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Comrade.components.tools.tools.Tools.urban"><code class="name">var <span class="ident">urban</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Comrade.components.tools.tools.Tools.on_message"><code class="name flex">
<span>async def <span class="ident">on_message</span></span>(<span>self, message: discord.message.Message)</span>
</code></dt>
<dd>
<div class="desc"><p>Inline calculator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@commands.Cog.listener()
async def on_message(self, message: discord.Message):
    &#39;&#39;&#39;
    Inline calculator
    &#39;&#39;&#39;
    if message.content and \
            not message.author.bot and message.content[:2] == &#34;==&#34;:
        await self.calculate(
            await self.bot.get_context(message),
            expression=message.content[2:])</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Comrade.components.tools" href="index.html">Comrade.components.tools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Comrade.components.tools.tools.Tools" href="#Comrade.components.tools.tools.Tools">Tools</a></code></h4>
<ul class="two-column">
<li><code><a title="Comrade.components.tools.tools.Tools.calculate" href="#Comrade.components.tools.tools.Tools.calculate">calculate</a></code></li>
<li><code><a title="Comrade.components.tools.tools.Tools.createChannel" href="#Comrade.components.tools.tools.Tools.createChannel">createChannel</a></code></li>
<li><code><a title="Comrade.components.tools.tools.Tools.define" href="#Comrade.components.tools.tools.Tools.define">define</a></code></li>
<li><code><a title="Comrade.components.tools.tools.Tools.graph" href="#Comrade.components.tools.tools.Tools.graph">graph</a></code></li>
<li><code><a title="Comrade.components.tools.tools.Tools.news" href="#Comrade.components.tools.tools.Tools.news">news</a></code></li>
<li><code><a title="Comrade.components.tools.tools.Tools.on_message" href="#Comrade.components.tools.tools.Tools.on_message">on_message</a></code></li>
<li><code><a title="Comrade.components.tools.tools.Tools.poll" href="#Comrade.components.tools.tools.Tools.poll">poll</a></code></li>
<li><code><a title="Comrade.components.tools.tools.Tools.tex" href="#Comrade.components.tools.tools.Tools.tex">tex</a></code></li>
<li><code><a title="Comrade.components.tools.tools.Tools.urban" href="#Comrade.components.tools.tools.Tools.urban">urban</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>